diff --git a/.github/workflows/wheels.yml b/.github/workflows/wheels.yml
index 67104433a..db152135d 100644
--- a/.github/workflows/wheels.yml
+++ b/.github/workflows/wheels.yml
@@ -23,7 +23,7 @@ jobs:
         with:
           components: llvm-tools-preview
       - name: Build wheels
-        uses: pypa/cibuildwheel@v2.17.0
+        uses: pypa/cibuildwheel@v2.16.5
         env:
           CIBW_BEFORE_BUILD: 'bash ./tools/build_pgo.sh /tmp/pgo-data/merged.profdata'
           CIBW_BEFORE_BUILD_WINDOWS: 'bash ./tools/build_pgo.sh /tmp/pgo-data/merged.profdata && cp /tmp/pgo-data/merged.profdata ~/.'
@@ -51,7 +51,7 @@ jobs:
         with:
           components: llvm-tools-preview
       - name: Build wheels
-        uses: pypa/cibuildwheel@v2.17.0
+        uses: pypa/cibuildwheel@v2.16.5
         env:
           CIBW_SKIP: 'pp* cp36-* cp37-* *musllinux* *amd64 *x86_64'
       - uses: actions/upload-artifact@v4
@@ -74,7 +74,7 @@ jobs:
           python-version: '3.10'
       - uses: dtolnay/rust-toolchain@stable
       - name: Build wheels
-        uses: pypa/cibuildwheel@v2.17.0
+        uses: pypa/cibuildwheel@v2.16.5
         env:
           CIBW_BEFORE_ALL: rustup target add aarch64-apple-darwin
           CIBW_ARCHS_MACOS: arm64 universal2
@@ -124,7 +124,7 @@ jobs:
         with:
           platforms: all
       - name: Build wheels
-        uses: pypa/cibuildwheel@v2.17.0
+        uses: pypa/cibuildwheel@v2.16.5
         env:
           CIBW_ARCHS_LINUX: s390x
           CIBW_TEST_SKIP: "cp*"
@@ -158,7 +158,7 @@ jobs:
         with:
           platforms: all
       - name: Build wheels
-        uses: pypa/cibuildwheel@v2.17.0
+        uses: pypa/cibuildwheel@v2.16.5
         env:
           CIBW_ARCHS_LINUX: ppc64le
           CIBW_TEST_SKIP: "cp*"
@@ -192,7 +192,7 @@ jobs:
         with:
           platforms: all
       - name: Build wheels
-        uses: pypa/cibuildwheel@v2.17.0
+        uses: pypa/cibuildwheel@v2.16.5
         env:
           CIBW_ARCHS_LINUX: aarch64
       - uses: actions/upload-artifact@v4
diff --git a/Cargo.lock b/Cargo.lock
index 4597de197..1fb29d80b 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -30,16 +30,6 @@ dependencies = [
  "log",
 ]
 
-[[package]]
-name = "approx"
-version = "0.5.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cab112f0a86d568ea0e627cc1d6be74a1e9cd55214684db5561995f6dad897c6"
-dependencies = [
- "num-complex",
- "num-traits",
-]
-
 [[package]]
 name = "ariadne"
 version = "0.3.0"
@@ -803,7 +793,6 @@ version = "0.15.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "adb12d4e967ec485a5f71c6311fe28158e9d6f4bc4a447b474184d0f91a8fa32"
 dependencies = [
- "approx",
  "matrixmultiply",
  "num-complex",
  "num-integer",
@@ -1048,9 +1037,9 @@ dependencies = [
 
 [[package]]
 name = "pulp"
-version = "0.18.9"
+version = "0.18.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "03457ac216146f43f921500bac4e892d5cd32b0479b929cbfc90f95cd6c599c2"
+checksum = "091bad01115892393939669b38f88ff2b70838e969a7ac172a9d06d05345a732"
 dependencies = [
  "bytemuck",
  "libm",
@@ -1089,7 +1078,6 @@ dependencies = [
  "pyo3-build-config",
  "pyo3-ffi",
  "pyo3-macros",
- "smallvec 1.13.1",
  "unindent",
 ]
 
@@ -1161,7 +1149,6 @@ name = "qiskit_accelerate"
 version = "1.1.0"
 dependencies = [
  "ahash",
- "approx",
  "faer",
  "faer-core",
  "hashbrown 0.14.3",
@@ -1478,9 +1465,9 @@ dependencies = [
 
 [[package]]
 name = "rustworkx-core"
-version = "0.14.2"
+version = "0.14.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "529027dfaa8125aa61bb7736ae9484f41e8544f448af96918c8da6b1def7f57b"
+checksum = "7dc64577832a6bcfd10fa6d452c3b5fe7a4ca228375d236f65a1ab0db953ba34"
 dependencies = [
  "ahash",
  "fixedbitset",
diff --git a/README.md b/README.md
index f63f90f11..9c7bbfb7f 100644
--- a/README.md
+++ b/README.md
@@ -110,6 +110,7 @@ Qiskit also provides a lower-level abstract interface for describing quantum bac
 ``qiskit.providers``, defines an abstract `BackendV2` class that providers can implement to represent their
 hardware or simulators to Qiskit. The backend class includes a common interface for executing circuits on the backends; however, in this interface each provider may perform different types of pre- and post-processing and return outcomes that are vendor-defined. Some examples of published provider packages that interface with real hardware are:
 
+* https://github.com/Qiskit/qiskit-ibm-provider
 * https://github.com/qiskit-community/qiskit-ionq
 * https://github.com/qiskit-community/qiskit-aqt-provider
 * https://github.com/qiskit-community/qiskit-braket-provider
@@ -126,7 +127,7 @@ on how to get access and use these systems.
 If you'd like to contribute to Qiskit, please take a look at our
 [contribution guidelines](CONTRIBUTING.md). By participating, you are expected to uphold our [code of conduct](CODE_OF_CONDUCT.md).
 
-We use [GitHub issues](https://github.com/Qiskit/qiskit/issues) for tracking requests and bugs. Please
+We use [GitHub issues](https://github.com/Qiskit/qiskit-terra/issues) for tracking requests and bugs. Please
 [join the Qiskit Slack community](https://qisk.it/join-slack) for discussion, comments, and questions.
 For questions related to running or using Qiskit, [Stack Overflow has a `qiskit`](https://stackoverflow.com/questions/tagged/qiskit).
 For questions on quantum computing with Qiskit, use the `qiskit` tag in the [Quantum Computing Stack Exchange](https://quantumcomputing.stackexchange.com/questions/tagged/qiskit) (please, read first the [guidelines on how to ask](https://quantumcomputing.stackexchange.com/help/how-to-ask) in that forum).
@@ -134,7 +135,7 @@ For questions on quantum computing with Qiskit, use the `qiskit` tag in the [Qua
 
 ## Authors and Citation
 
-Qiskit is the work of [many people](https://github.com/Qiskit/qiskit/graphs/contributors) who contribute
+Qiskit is the work of [many people](https://github.com/Qiskit/qiskit-terra/graphs/contributors) who contribute
 to the project at different levels. If you use Qiskit, please cite as per the included [BibTeX file](CITATION.bib).
 
 ## Changelog and Release Notes
@@ -146,7 +147,7 @@ find the page for the `0.46.0` release here:
 <https://github.com/Qiskit/qiskit/releases/tag/0.46.0>
 
 The changelog for the current release can be found in the releases tab:
-[![Releases](https://img.shields.io/github/release/Qiskit/qiskit.svg?style=flat&label=)](https://github.com/Qiskit/qiskit/releases)
+[![Releases](https://img.shields.io/github/release/Qiskit/qiskit-terra.svg?style=flat&label=)](https://github.com/Qiskit/qiskit/releases)
 The changelog provides a quick overview of notable changes for a given
 release.
 
diff --git a/crates/accelerate/Cargo.toml b/crates/accelerate/Cargo.toml
index d7a59468a..5c4ba8149 100644
--- a/crates/accelerate/Cargo.toml
+++ b/crates/accelerate/Cargo.toml
@@ -33,15 +33,11 @@ features = ["union"]
 
 [dependencies.pyo3]
 workspace = true
-features = ["hashbrown", "indexmap", "num-complex", "num-bigint", "smallvec"]
+features = ["hashbrown", "indexmap", "num-complex", "num-bigint"]
 
 [dependencies.ndarray]
 version = "^0.15.6"
-features = ["rayon", "approx-0_5"]
-
-[dependencies.approx]
-version = "0.5"
-features = ["num-complex"]
+features = ["rayon"]
 
 [dependencies.hashbrown]
 workspace = true
@@ -56,5 +52,5 @@ version = "0.17.0"
 features = ["ndarray"]
 
 [dependencies.pulp]
-version = "0.18.9"
+version = "0.18.8"
 features = ["macro"]
diff --git a/crates/accelerate/src/euler_one_qubit_decomposer.rs b/crates/accelerate/src/euler_one_qubit_decomposer.rs
index 5f9f479f6..e74f70006 100644
--- a/crates/accelerate/src/euler_one_qubit_decomposer.rs
+++ b/crates/accelerate/src/euler_one_qubit_decomposer.rs
@@ -11,17 +11,14 @@
 // that they have been altered from the originals.
 
 #![allow(clippy::too_many_arguments)]
-#![allow(clippy::upper_case_acronyms)]
 
 use hashbrown::HashMap;
 use num_complex::{Complex64, ComplexFloat};
-use smallvec::{smallvec, SmallVec};
 use std::cmp::Ordering;
 use std::f64::consts::PI;
 
-use pyo3::exceptions::{PyIndexError, PyValueError};
+use pyo3::exceptions::{PyIndexError, PyTypeError};
 use pyo3::prelude::*;
-use pyo3::types::PyString;
 use pyo3::wrap_pyfunction;
 use pyo3::Python;
 
@@ -30,7 +27,7 @@ use numpy::PyReadonlyArray2;
 
 use crate::utils::SliceOrInt;
 
-pub const ANGLE_ZERO_EPSILON: f64 = 1e-12;
+const DEFAULT_ATOL: f64 = 1e-12;
 
 #[pyclass(module = "qiskit._accelerate.euler_one_qubit_decomposer")]
 pub struct OneQubitGateErrorMap {
@@ -64,13 +61,11 @@ impl OneQubitGateErrorMap {
 
 #[pyclass(sequence)]
 pub struct OneQubitGateSequence {
-    pub gates: Vec<(String, SmallVec<[f64; 3]>)>,
+    gates: Vec<(String, Vec<f64>)>,
     #[pyo3(get)]
-    pub global_phase: f64,
+    global_phase: f64,
 }
 
-type OneQubitGateSequenceState = (Vec<(String, SmallVec<[f64; 3]>)>, f64);
-
 #[pymethods]
 impl OneQubitGateSequence {
     #[new]
@@ -80,11 +75,11 @@ impl OneQubitGateSequence {
             global_phase: 0.,
         }
     }
-    fn __getstate__(&self) -> OneQubitGateSequenceState {
+    fn __getstate__(&self) -> (Vec<(String, Vec<f64>)>, f64) {
         (self.gates.clone(), self.global_phase)
     }
 
-    fn __setstate__(&mut self, state: OneQubitGateSequenceState) {
+    fn __setstate__(&mut self, state: (Vec<(String, Vec<f64>)>, f64)) {
         self.gates = state.0;
         self.global_phase = state.1;
     }
@@ -98,7 +93,7 @@ impl OneQubitGateSequence {
             SliceOrInt::Slice(slc) => {
                 let len = self.gates.len().try_into().unwrap();
                 let indices = slc.indices(len)?;
-                let mut out_vec: Vec<(String, SmallVec<[f64; 3]>)> = Vec::new();
+                let mut out_vec: Vec<(String, Vec<f64>)> = Vec::new();
                 // Start and stop will always be positive the slice api converts
                 // negatives to the index for example:
                 // list(range(5))[-1:-3:-1]
@@ -150,10 +145,10 @@ fn circuit_kak(
     let mut lam = lam;
     let mut theta = theta;
     let mut phi = phi;
-    let mut circuit: Vec<(String, SmallVec<[f64; 3]>)> = Vec::with_capacity(3);
+    let mut circuit: Vec<(String, Vec<f64>)> = Vec::with_capacity(3);
     let mut atol = match atol {
         Some(atol) => atol,
-        None => ANGLE_ZERO_EPSILON,
+        None => DEFAULT_ATOL,
     };
     if !simplify {
         atol = -1.0;
@@ -166,7 +161,7 @@ fn circuit_kak(
         // slippage coming from _mod_2pi injecting multiples of 2pi.
         lam = mod_2pi(lam, atol);
         if lam.abs() > atol {
-            circuit.push((String::from(k_gate), smallvec![lam]));
+            circuit.push((String::from(k_gate), vec![lam]));
             global_phase += lam / 2.;
         }
         return OneQubitGateSequence {
@@ -187,13 +182,13 @@ fn circuit_kak(
     lam = mod_2pi(lam, atol);
     if lam.abs() > atol {
         global_phase += lam / 2.;
-        circuit.push((String::from(k_gate), smallvec![lam]));
+        circuit.push((String::from(k_gate), vec![lam]));
     }
-    circuit.push((String::from(a_gate), smallvec![theta]));
+    circuit.push((String::from(a_gate), vec![theta]));
     phi = mod_2pi(phi, atol);
     if phi.abs() > atol {
         global_phase += phi / 2.;
-        circuit.push((String::from(k_gate), smallvec![phi]));
+        circuit.push((String::from(k_gate), vec![phi]));
     }
     OneQubitGateSequence {
         gates: circuit,
@@ -212,12 +207,12 @@ fn circuit_u3(
     let mut circuit = Vec::new();
     let atol = match atol {
         Some(atol) => atol,
-        None => ANGLE_ZERO_EPSILON,
+        None => DEFAULT_ATOL,
     };
     let phi = mod_2pi(phi, atol);
     let lam = mod_2pi(lam, atol);
     if !simplify || theta.abs() > atol || phi.abs() > atol || lam.abs() > atol {
-        circuit.push((String::from("u3"), smallvec![theta, phi, lam]));
+        circuit.push((String::from("u3"), vec![theta, phi, lam]));
     }
     OneQubitGateSequence {
         gates: circuit,
@@ -236,7 +231,7 @@ fn circuit_u321(
     let mut circuit = Vec::new();
     let mut atol = match atol {
         Some(atol) => atol,
-        None => ANGLE_ZERO_EPSILON,
+        None => DEFAULT_ATOL,
     };
     if !simplify {
         atol = -1.0;
@@ -244,17 +239,17 @@ fn circuit_u321(
     if theta.abs() < atol {
         let tot = mod_2pi(phi + lam, atol);
         if tot.abs() > atol {
-            circuit.push((String::from("u1"), smallvec![tot]));
+            circuit.push((String::from("u1"), vec![tot]));
         }
     } else if (theta - PI / 2.).abs() < atol {
         circuit.push((
             String::from("u2"),
-            smallvec![mod_2pi(phi, atol), mod_2pi(lam, atol)],
+            vec![mod_2pi(phi, atol), mod_2pi(lam, atol)],
         ));
     } else {
         circuit.push((
             String::from("u3"),
-            smallvec![theta, mod_2pi(phi, atol), mod_2pi(lam, atol)],
+            vec![theta, mod_2pi(phi, atol), mod_2pi(lam, atol)],
         ));
     }
     OneQubitGateSequence {
@@ -274,7 +269,7 @@ fn circuit_u(
     let mut circuit = Vec::new();
     let mut atol = match atol {
         Some(atol) => atol,
-        None => ANGLE_ZERO_EPSILON,
+        None => DEFAULT_ATOL,
     };
     if !simplify {
         atol = -1.0;
@@ -282,7 +277,7 @@ fn circuit_u(
     let phi = mod_2pi(phi, atol);
     let lam = mod_2pi(lam, atol);
     if theta.abs() > atol || phi.abs() > atol || lam.abs() > atol {
-        circuit.push((String::from("u"), smallvec![theta, phi, lam]));
+        circuit.push((String::from("u"), vec![theta, phi, lam]));
     }
     OneQubitGateSequence {
         gates: circuit,
@@ -315,7 +310,7 @@ where
     };
     let mut atol = match atol {
         Some(atol) => atol,
-        None => ANGLE_ZERO_EPSILON,
+        None => DEFAULT_ATOL,
     };
     if !simplify {
         atol = -1.0;
@@ -375,7 +370,7 @@ fn circuit_rr(
     let mut circuit = Vec::new();
     let mut atol = match atol {
         Some(atol) => atol,
-        None => ANGLE_ZERO_EPSILON,
+        None => DEFAULT_ATOL,
     };
     if !simplify {
         atol = -1.0;
@@ -384,22 +379,19 @@ fn circuit_rr(
     if mod_2pi((phi + lam) / 2., atol).abs() < atol {
         // This can be expressed as a single R gate
         if theta.abs() > atol {
-            circuit.push((
-                String::from("r"),
-                smallvec![theta, mod_2pi(PI / 2. + phi, atol)],
-            ));
+            circuit.push((String::from("r"), vec![theta, mod_2pi(PI / 2. + phi, atol)]));
         }
     } else {
         // General case: use two R gates
         if (theta - PI).abs() > atol {
             circuit.push((
                 String::from("r"),
-                smallvec![theta - PI, mod_2pi(PI / 2. - lam, atol)],
+                vec![theta - PI, mod_2pi(PI / 2. - lam, atol)],
             ));
         }
         circuit.push((
             String::from("r"),
-            smallvec![PI, mod_2pi(0.5 * (phi - lam + PI), atol)],
+            vec![PI, mod_2pi(0.5 * (phi - lam + PI), atol)],
         ));
     }
 
@@ -411,7 +403,7 @@ fn circuit_rr(
 
 #[pyfunction]
 pub fn generate_circuit(
-    target_basis: &EulerBasis,
+    target_basis: &str,
     theta: f64,
     phi: f64,
     lam: f64,
@@ -420,17 +412,17 @@ pub fn generate_circuit(
     atol: Option<f64>,
 ) -> PyResult<OneQubitGateSequence> {
     let res = match target_basis {
-        EulerBasis::ZYZ => circuit_kak(theta, phi, lam, phase, "rz", "ry", simplify, atol),
-        EulerBasis::ZXZ => circuit_kak(theta, phi, lam, phase, "rz", "rx", simplify, atol),
-        EulerBasis::XZX => circuit_kak(theta, phi, lam, phase, "rx", "rz", simplify, atol),
-        EulerBasis::XYX => circuit_kak(theta, phi, lam, phase, "rx", "ry", simplify, atol),
-        EulerBasis::U3 => circuit_u3(theta, phi, lam, phase, simplify, atol),
-        EulerBasis::U321 => circuit_u321(theta, phi, lam, phase, simplify, atol),
-        EulerBasis::U => circuit_u(theta, phi, lam, phase, simplify, atol),
-        EulerBasis::PSX => {
+        "ZYZ" => circuit_kak(theta, phi, lam, phase, "rz", "ry", simplify, atol),
+        "ZXZ" => circuit_kak(theta, phi, lam, phase, "rz", "rx", simplify, atol),
+        "XZX" => circuit_kak(theta, phi, lam, phase, "rx", "rz", simplify, atol),
+        "XYX" => circuit_kak(theta, phi, lam, phase, "rx", "ry", simplify, atol),
+        "U3" => circuit_u3(theta, phi, lam, phase, simplify, atol),
+        "U321" => circuit_u321(theta, phi, lam, phase, simplify, atol),
+        "U" => circuit_u(theta, phi, lam, phase, simplify, atol),
+        "PSX" => {
             let mut inner_atol = match atol {
                 Some(atol) => atol,
-                None => ANGLE_ZERO_EPSILON,
+                None => DEFAULT_ATOL,
             };
             if !simplify {
                 inner_atol = -1.0;
@@ -438,11 +430,11 @@ pub fn generate_circuit(
             let fnz = |circuit: &mut OneQubitGateSequence, phi: f64| {
                 let phi = mod_2pi(phi, inner_atol);
                 if phi.abs() > inner_atol {
-                    circuit.gates.push((String::from("p"), smallvec![phi]));
+                    circuit.gates.push((String::from("p"), vec![phi]));
                 }
             };
             let fnx = |circuit: &mut OneQubitGateSequence| {
-                circuit.gates.push((String::from("sx"), SmallVec::new()));
+                circuit.gates.push((String::from("sx"), Vec::new()));
             };
 
             circuit_psx_gen(
@@ -457,10 +449,10 @@ pub fn generate_circuit(
                 None::<Box<dyn FnOnce(&mut OneQubitGateSequence)>>,
             )
         }
-        EulerBasis::ZSX => {
+        "ZSX" => {
             let mut inner_atol = match atol {
                 Some(atol) => atol,
-                None => ANGLE_ZERO_EPSILON,
+                None => DEFAULT_ATOL,
             };
             if !simplify {
                 inner_atol = -1.0;
@@ -468,12 +460,12 @@ pub fn generate_circuit(
             let fnz = |circuit: &mut OneQubitGateSequence, phi: f64| {
                 let phi = mod_2pi(phi, inner_atol);
                 if phi.abs() > inner_atol {
-                    circuit.gates.push((String::from("rz"), smallvec![phi]));
+                    circuit.gates.push((String::from("rz"), vec![phi]));
                     circuit.global_phase += phi / 2.;
                 }
             };
             let fnx = |circuit: &mut OneQubitGateSequence| {
-                circuit.gates.push((String::from("sx"), SmallVec::new()));
+                circuit.gates.push((String::from("sx"), Vec::new()));
             };
             circuit_psx_gen(
                 theta,
@@ -487,10 +479,10 @@ pub fn generate_circuit(
                 None::<Box<dyn FnOnce(&mut OneQubitGateSequence)>>,
             )
         }
-        EulerBasis::U1X => {
+        "U1X" => {
             let mut inner_atol = match atol {
                 Some(atol) => atol,
-                None => ANGLE_ZERO_EPSILON,
+                None => DEFAULT_ATOL,
             };
             if !simplify {
                 inner_atol = -1.0;
@@ -498,12 +490,12 @@ pub fn generate_circuit(
             let fnz = |circuit: &mut OneQubitGateSequence, phi: f64| {
                 let phi = mod_2pi(phi, inner_atol);
                 if phi.abs() > inner_atol {
-                    circuit.gates.push((String::from("u1"), smallvec![phi]));
+                    circuit.gates.push((String::from("u1"), vec![phi]));
                 }
             };
             let fnx = |circuit: &mut OneQubitGateSequence| {
                 circuit.global_phase += PI / 4.;
-                circuit.gates.push((String::from("rx"), smallvec![PI / 2.]));
+                circuit.gates.push((String::from("rx"), vec![PI / 2.]));
             };
             circuit_psx_gen(
                 theta,
@@ -517,10 +509,10 @@ pub fn generate_circuit(
                 None::<Box<dyn FnOnce(&mut OneQubitGateSequence)>>,
             )
         }
-        EulerBasis::ZSXX => {
+        "ZSXX" => {
             let mut inner_atol = match atol {
                 Some(atol) => atol,
-                None => ANGLE_ZERO_EPSILON,
+                None => DEFAULT_ATOL,
             };
             if !simplify {
                 inner_atol = -1.0;
@@ -528,15 +520,15 @@ pub fn generate_circuit(
             let fnz = |circuit: &mut OneQubitGateSequence, phi: f64| {
                 let phi = mod_2pi(phi, inner_atol);
                 if phi.abs() > inner_atol {
-                    circuit.gates.push((String::from("rz"), smallvec![phi]));
+                    circuit.gates.push((String::from("rz"), vec![phi]));
                     circuit.global_phase += phi / 2.;
                 }
             };
             let fnx = |circuit: &mut OneQubitGateSequence| {
-                circuit.gates.push((String::from("sx"), SmallVec::new()));
+                circuit.gates.push((String::from("sx"), Vec::new()));
             };
             let fnxpi = |circuit: &mut OneQubitGateSequence| {
-                circuit.gates.push((String::from("x"), SmallVec::new()));
+                circuit.gates.push((String::from("x"), Vec::new()));
             };
             circuit_psx_gen(
                 theta,
@@ -550,93 +542,32 @@ pub fn generate_circuit(
                 Some(fnxpi),
             )
         }
-        EulerBasis::RR => circuit_rr(theta, phi, lam, phase, simplify, atol),
+        "RR" => circuit_rr(theta, phi, lam, phase, simplify, atol),
+        other => {
+            return Err(PyTypeError::new_err(format!(
+                "Invalid target basis: {other}"
+            )))
+        }
     };
     Ok(res)
 }
 
-#[derive(Clone, Debug, Copy)]
-#[pyclass(module = "qiskit._accelerate.euler_one_qubit_decomposer")]
-pub enum EulerBasis {
-    U321,
-    U3,
-    U,
-    PSX,
-    ZSX,
-    ZSXX,
-    U1X,
-    RR,
-    ZYZ,
-    ZXZ,
-    XYX,
-    XZX,
-}
-
-impl EulerBasis {
-    pub fn as_str(&self) -> &'static str {
-        match self {
-            Self::U321 => "U321",
-            Self::U3 => "U3",
-            Self::U => "U",
-            Self::PSX => "PSX",
-            Self::ZSX => "ZSX",
-            Self::ZSXX => "ZSXX",
-            Self::U1X => "U1X",
-            Self::RR => "RR",
-            Self::ZYZ => "ZYZ",
-            Self::ZXZ => "ZXZ",
-            Self::XYX => "XYX",
-            Self::XZX => "XZX",
-        }
-    }
-}
-
-#[pymethods]
-impl EulerBasis {
-    fn __reduce__(&self, py: Python) -> Py<PyAny> {
-        (py.get_type::<Self>(), (PyString::new(py, self.as_str()),)).into_py(py)
-    }
-
-    #[new]
-    pub fn from_str(input: &str) -> PyResult<Self> {
-        let res = match input {
-            "U321" => EulerBasis::U321,
-            "U3" => EulerBasis::U3,
-            "U" => EulerBasis::U,
-            "PSX" => EulerBasis::PSX,
-            "ZSX" => EulerBasis::ZSX,
-            "ZSXX" => EulerBasis::ZSXX,
-            "U1X" => EulerBasis::U1X,
-            "RR" => EulerBasis::RR,
-            "ZYZ" => EulerBasis::ZYZ,
-            "ZXZ" => EulerBasis::ZXZ,
-            "XYX" => EulerBasis::XYX,
-            "XZX" => EulerBasis::XZX,
-            basis => {
-                return Err(PyValueError::new_err(format!(
-                    "Invalid target basis '{basis}'"
-                )));
-            }
-        };
-        Ok(res)
-    }
-}
-
 #[inline]
-pub fn angles_from_unitary(unitary: ArrayView2<Complex64>, target_basis: EulerBasis) -> [f64; 4] {
+fn angles_from_unitary(unitary: ArrayView2<Complex64>, target_basis: &str) -> [f64; 4] {
     match target_basis {
-        EulerBasis::U321 => params_u3_inner(unitary),
-        EulerBasis::U3 => params_u3_inner(unitary),
-        EulerBasis::U => params_u3_inner(unitary),
-        EulerBasis::PSX => params_u1x_inner(unitary),
-        EulerBasis::ZSX => params_u1x_inner(unitary),
-        EulerBasis::ZSXX => params_u1x_inner(unitary),
-        EulerBasis::U1X => params_u1x_inner(unitary),
-        EulerBasis::RR => params_zyz_inner(unitary),
-        EulerBasis::ZYZ => params_zyz_inner(unitary),
-        EulerBasis::ZXZ => params_zxz_inner(unitary),
-        EulerBasis::XYX => params_xyx_inner(unitary),
-        EulerBasis::XZX => params_xzx_inner(unitary),
+        "U321" => params_u3_inner(unitary),
+        "U3" => params_u3_inner(unitary),
+        "U" => params_u3_inner(unitary),
+        "PSX" => params_u1x_inner(unitary),
+        "ZSX" => params_u1x_inner(unitary),
+        "ZSXX" => params_u1x_inner(unitary),
+        "U1X" => params_u1x_inner(unitary),
+        "RR" => params_zyz_inner(unitary),
+        "ZYZ" => params_zyz_inner(unitary),
+        "ZXZ" => params_zxz_inner(unitary),
+        "XYX" => params_xyx_inner(unitary),
+        "XZX" => params_xzx_inner(unitary),
+        &_ => unreachable!(),
     }
 }
 
@@ -661,7 +592,7 @@ fn compare_error_fn(
 }
 
 fn compute_error(
-    gates: &[(String, SmallVec<[f64; 3]>)],
+    gates: &[(String, Vec<f64>)],
     error_map: Option<&OneQubitGateErrorMap>,
     qubit: usize,
 ) -> (f64, usize) {
@@ -689,7 +620,7 @@ pub fn compute_error_one_qubit_sequence(
 
 #[pyfunction]
 pub fn compute_error_list(
-    circuit: Vec<(String, SmallVec<[f64; 3]>)>,
+    circuit: Vec<(String, Vec<f64>)>,
     qubit: usize,
     error_map: Option<&OneQubitGateErrorMap>,
 ) -> (f64, usize) {
@@ -706,46 +637,33 @@ pub fn unitary_to_gate_sequence(
     simplify: bool,
     atol: Option<f64>,
 ) -> PyResult<Option<OneQubitGateSequence>> {
-    let mut target_basis_vec: Vec<EulerBasis> = Vec::with_capacity(target_basis_list.len());
-    for basis in target_basis_list {
-        let basis_enum = EulerBasis::from_str(basis)?;
-        target_basis_vec.push(basis_enum)
+    const VALID_BASES: [&str; 12] = [
+        "U321", "U3", "U", "PSX", "ZSX", "ZSXX", "U1X", "RR", "ZYZ", "ZXZ", "XYX", "XZX",
+    ];
+    for basis in &target_basis_list {
+        if !VALID_BASES.contains(basis) {
+            return Err(PyTypeError::new_err(format!(
+                "Invalid target basis {basis}"
+            )));
+        }
     }
     let unitary_mat = unitary.as_array();
-    Ok(unitary_to_gate_sequence_inner(
-        unitary_mat,
-        &target_basis_vec,
-        qubit,
-        error_map,
-        simplify,
-        atol,
-    ))
-}
-
-#[inline]
-pub fn unitary_to_gate_sequence_inner(
-    unitary_mat: ArrayView2<Complex64>,
-    target_basis_list: &[EulerBasis],
-    qubit: usize,
-    error_map: Option<&OneQubitGateErrorMap>,
-    simplify: bool,
-    atol: Option<f64>,
-) -> Option<OneQubitGateSequence> {
-    target_basis_list
+    let best_result = target_basis_list
         .iter()
         .map(|target_basis| {
-            let [theta, phi, lam, phase] = angles_from_unitary(unitary_mat, *target_basis);
+            let [theta, phi, lam, phase] = angles_from_unitary(unitary_mat, target_basis);
             generate_circuit(target_basis, theta, phi, lam, phase, simplify, atol).unwrap()
         })
         .min_by(|a, b| {
             let error_a = compare_error_fn(a, &error_map, qubit);
             let error_b = compare_error_fn(b, &error_map, qubit);
             error_a.partial_cmp(&error_b).unwrap_or(Ordering::Equal)
-        })
+        });
+    Ok(best_result)
 }
 
 #[inline]
-pub fn det_one_qubit(mat: ArrayView2<Complex64>) -> Complex64 {
+fn det_one_qubit(mat: ArrayView2<Complex64>) -> Complex64 {
     mat[[0, 0]] * mat[[1, 1]] - mat[[0, 1]] * mat[[1, 0]]
 }
 
@@ -886,6 +804,5 @@ pub fn euler_one_qubit_decomposer(_py: Python, m: &PyModule) -> PyResult<()> {
     m.add_wrapped(wrap_pyfunction!(compute_error_list))?;
     m.add_class::<OneQubitGateSequence>()?;
     m.add_class::<OneQubitGateErrorMap>()?;
-    m.add_class::<EulerBasis>()?;
     Ok(())
 }
diff --git a/crates/accelerate/src/two_qubit_decompose.rs b/crates/accelerate/src/two_qubit_decompose.rs
index 6c4744174..d9f451a43 100644
--- a/crates/accelerate/src/two_qubit_decompose.rs
+++ b/crates/accelerate/src/two_qubit_decompose.rs
@@ -18,127 +18,59 @@
 // of real components and one of imaginary components.
 // In order to avoid copying we want to use `MatRef<c64>` or `MatMut<c64>`.
 
-use approx::abs_diff_eq;
-use num_complex::{Complex, Complex64, ComplexFloat};
-use pyo3::exceptions::{PyIndexError, PyValueError};
-use pyo3::import_exception;
+use num_complex::Complex;
 use pyo3::prelude::*;
 use pyo3::wrap_pyfunction;
 use pyo3::Python;
-use smallvec::{smallvec, SmallVec};
 use std::f64::consts::PI;
 
 use faer::IntoFaerComplex;
-use faer::IntoNdarray;
-use faer::IntoNdarrayComplex;
-use faer::Side::Lower;
-use faer::{prelude::*, scale, Mat, MatRef};
+use faer::{mat, prelude::*, scale, Mat, MatRef};
 use faer_core::{c64, ComplexField};
-use ndarray::linalg::kron;
-use ndarray::prelude::*;
-use ndarray::Zip;
 use numpy::PyReadonlyArray2;
-use numpy::ToPyArray;
 
-use crate::euler_one_qubit_decomposer::{
-    angles_from_unitary, det_one_qubit, unitary_to_gate_sequence_inner, EulerBasis,
-    ANGLE_ZERO_EPSILON,
-};
 use crate::utils;
 
-use rand::prelude::*;
-use rand_distr::StandardNormal;
-use rand_pcg::Pcg64Mcg;
-
 const PI2: f64 = PI / 2.0;
 const PI4: f64 = PI / 4.0;
 const PI32: f64 = 3.0 * PI2;
-const TWO_PI: f64 = 2.0 * PI;
-
+const C0: c64 = c64 { re: 0.0, im: 0.0 };
 const C1: c64 = c64 { re: 1.0, im: 0.0 };
-
-const ONE_QUBIT_IDENTITY: [[Complex64; 2]; 2] = [
-    [Complex64::new(1., 0.), Complex64::new(0., 0.)],
-    [Complex64::new(0., 0.), Complex64::new(1., 0.)],
+const C1_NEG: c64 = c64 { re: -1.0, im: 0.0 };
+const C1IM: c64 = c64 { re: 0.0, im: 1.0 };
+const C1_NEG_IM: c64 = c64 { re: 0.0, im: -1.0 };
+const C0_5: c64 = c64 { re: 0.5, im: 0.0 };
+const C0_5_NEG: c64 = c64 { re: -0.5, im: 0.0 };
+const C0_5_IM: c64 = c64 { re: 0.0, im: 0.5 };
+const C0_5_IM_NEG: c64 = c64 { re: 0.0, im: -0.5 };
+
+const B_NON_NORMALIZED: [c64; 16] = [
+    C1, C1IM, C0, C0, C0, C0, C1IM, C1, C0, C0, C1IM, C1_NEG, C1, C1_NEG_IM, C0, C0,
 ];
 
-const B_NON_NORMALIZED: [[Complex64; 4]; 4] = [
-    [
-        Complex64::new(1.0, 0.),
-        Complex64::new(0., 1.),
-        Complex64::new(0., 0.),
-        Complex64::new(0., 0.),
-    ],
-    [
-        Complex64::new(0., 0.),
-        Complex64::new(0., 0.),
-        Complex64::new(0., 1.),
-        Complex64::new(1.0, 0.0),
-    ],
-    [
-        Complex64::new(0., 0.),
-        Complex64::new(0., 0.),
-        Complex64::new(0., 1.),
-        Complex64::new(-1., 0.),
-    ],
-    [
-        Complex64::new(1., 0.),
-        Complex64::new(0., -1.),
-        Complex64::new(0., 0.),
-        Complex64::new(0., 0.),
-    ],
+const B_NON_NORMALIZED_DAGGER: [c64; 16] = [
+    C0_5,
+    C0,
+    C0,
+    C0_5,
+    C0_5_IM_NEG,
+    C0,
+    C0,
+    C0_5_IM,
+    C0,
+    C0_5_IM_NEG,
+    C0_5_IM_NEG,
+    C0,
+    C0,
+    C0_5,
+    C0_5_NEG,
+    C0,
 ];
 
-const B_NON_NORMALIZED_DAGGER: [[Complex64; 4]; 4] = [
-    [
-        Complex64::new(0.5, 0.),
-        Complex64::new(0., 0.),
-        Complex64::new(0., 0.),
-        Complex64::new(0.5, 0.0),
-    ],
-    [
-        Complex64::new(0., -0.5),
-        Complex64::new(0., 0.),
-        Complex64::new(0., 0.),
-        Complex64::new(0., 0.5),
-    ],
-    [
-        Complex64::new(0., 0.),
-        Complex64::new(0., -0.5),
-        Complex64::new(0., -0.5),
-        Complex64::new(0., 0.),
-    ],
-    [
-        Complex64::new(0., 0.),
-        Complex64::new(0.5, 0.),
-        Complex64::new(-0.5, 0.),
-        Complex64::new(0., 0.),
-    ],
-];
-
-enum MagicBasisTransform {
-    Into,
-    OutOf,
-}
-
-fn magic_basis_transform(
-    unitary: ArrayView2<Complex64>,
-    direction: MagicBasisTransform,
-) -> Array2<Complex64> {
-    let _b_nonnormalized = aview2(&B_NON_NORMALIZED);
-    let _b_nonnormalized_dagger = aview2(&B_NON_NORMALIZED_DAGGER);
-    match direction {
-        MagicBasisTransform::OutOf => _b_nonnormalized_dagger.dot(&unitary).dot(&_b_nonnormalized),
-        MagicBasisTransform::Into => _b_nonnormalized.dot(&unitary).dot(&_b_nonnormalized_dagger),
-    }
-}
-
-fn transform_from_magic_basis(u: Mat<c64>) -> Mat<c64> {
-    let unitary: ArrayView2<Complex64> = u.as_ref().into_ndarray_complex();
-    magic_basis_transform(unitary, MagicBasisTransform::OutOf)
-        .view()
-        .into_faer_complex()
-        .to_owned()
+fn transform_from_magic_basis(unitary: Mat<c64>) -> Mat<c64> {
+    let _b_nonnormalized = mat::from_row_major_slice::<c64>(&B_NON_NORMALIZED, 4, 4);
+    let _b_nonnormalized_dagger = mat::from_row_major_slice::<c64>(&B_NON_NORMALIZED_DAGGER, 4, 4);
+    _b_nonnormalized_dagger * unitary * _b_nonnormalized
 }
 
 // faer::c64 and num_complex::Complex<f64> are both structs
@@ -166,57 +98,6 @@ impl Arg for c64 {
     }
 }
 
-pub trait TraceToFidelity {
-    /// Average gate fidelity is :math:`Fbar = (d + |Tr (Utarget \\cdot U^dag)|^2) / d(d+1)`
-    /// M. Horodecki, P. Horodecki and R. Horodecki, PRA 60, 1888 (1999)
-    fn trace_to_fid(self) -> f64;
-}
-
-impl TraceToFidelity for Complex64 {
-    fn trace_to_fid(self) -> f64 {
-        (4.0 + self.abs().powi(2)) / 20.0
-    }
-}
-
-impl TraceToFidelity for c64 {
-    fn trace_to_fid(self) -> f64 {
-        (4.0 + self.faer_abs2()) / 20.0
-    }
-}
-
-fn decompose_two_qubit_product_gate(
-    special_unitary: ArrayView2<Complex64>,
-) -> PyResult<(Array2<Complex64>, Array2<Complex64>, f64)> {
-    let mut r: Array2<Complex64> = special_unitary.slice(s![..2, ..2]).to_owned();
-    let mut det_r = det_one_qubit(r.view());
-    if det_r.abs() < 0.1 {
-        r = special_unitary.slice(s![2.., ..2]).to_owned();
-        det_r = det_one_qubit(r.view());
-    }
-    if det_r.abs() < 0.1 {
-        import_exception!(qiskit, QiskitError);
-        return Err(QiskitError::new_err(
-            "decompose_two_qubit_product_gate: unable to decompose: detR < 0.1",
-        ));
-    }
-    r.mapv_inplace(|x| x / det_r.sqrt());
-    let r_t_conj: Array2<Complex64> = r.t().mapv(|x| x.conj());
-    let eye = aview2(&ONE_QUBIT_IDENTITY);
-    let mut temp = kron(&eye, &r_t_conj);
-    temp = special_unitary.dot(&temp);
-    let mut l = temp.slice(s![..;2, ..;2]).to_owned();
-    let det_l = det_one_qubit(l.view());
-    if det_l.abs() < 0.9 {
-        import_exception!(qiskit, QiskitError);
-        return Err(QiskitError::new_err(
-            "decompose_two_qubit_product_gate: unable to decompose: detL < 0.9",
-        ));
-    }
-    l.mapv_inplace(|x| x / det_l.sqrt());
-    let phase = det_l.arg() / 2.;
-    Ok((l, r, phase))
-}
-
 fn __weyl_coordinates(unitary: MatRef<c64>) -> [f64; 3] {
     let uscaled = scale(C1 / unitary.determinant().powf(0.25)) * unitary;
     let uup = transform_from_magic_basis(uscaled);
@@ -299,903 +180,20 @@ fn __num_basis_gates(basis_b: f64, basis_fidelity: f64, unitary: MatRef<c64>) ->
     traces
         .into_iter()
         .enumerate()
-        .map(|(idx, trace)| (idx, trace.trace_to_fid() * basis_fidelity.powi(idx as i32)))
+        .map(|(idx, trace)| (idx, trace_to_fid(&trace) * basis_fidelity.powi(idx as i32)))
         .min_by(|(_idx1, fid1), (_idx2, fid2)| fid2.partial_cmp(fid1).unwrap())
         .unwrap()
         .0
 }
 
-/// A good approximation to the best value x to get the minimum
-/// trace distance for :math:`U_d(x, x, x)` from :math:`U_d(a, b, c)`.
-fn closest_partial_swap(a: f64, b: f64, c: f64) -> f64 {
-    let m = (a + b + c) / 3.;
-    let [am, bm, cm] = [a - m, b - m, c - m];
-    let [ab, bc, ca] = [a - b, b - c, c - a];
-    m + am * bm * cm * (6. + ab * ab + bc * bc + ca * ca) / 18.
-}
-
-fn rx_matrix(theta: f64) -> Array2<Complex64> {
-    let half_theta = theta / 2.;
-    let cos = Complex64::new(half_theta.cos(), 0.);
-    let isin = Complex64::new(0., -half_theta.sin());
-    array![[cos, isin], [isin, cos]]
-}
-
-fn ry_matrix(theta: f64) -> Array2<Complex64> {
-    let half_theta = theta / 2.;
-    let cos = Complex64::new(half_theta.cos(), 0.);
-    let sin = Complex64::new(half_theta.sin(), 0.);
-    array![[cos, -sin], [sin, cos]]
-}
-
-fn rz_matrix(theta: f64) -> Array2<Complex64> {
-    let ilam2 = Complex64::new(0., 0.5 * theta);
-    array![
-        [(-ilam2).exp(), Complex64::new(0., 0.)],
-        [Complex64::new(0., 0.), ilam2.exp()]
-    ]
-}
-
-const DEFAULT_FIDELITY: f64 = 1.0 - 1.0e-9;
-const C1_IM: Complex64 = Complex64::new(0.0, 1.0);
-
-#[derive(Clone, Debug, Copy)]
-#[pyclass(module = "qiskit._accelerate.two_qubit_decompose")]
-enum Specialization {
-    General,
-    IdEquiv,
-    SWAPEquiv,
-    PartialSWAPEquiv,
-    PartialSWAPFlipEquiv,
-    ControlledEquiv,
-    MirrorControlledEquiv,
-    // These next 3 gates use the definition of fSim from eq (1) in:
-    // https://arxiv.org/pdf/2001.08343.pdf
-    #[allow(non_camel_case_types)]
-    fSimaabEquiv,
-    #[allow(non_camel_case_types)]
-    fSimabbEquiv,
-    #[allow(non_camel_case_types)]
-    fSimabmbEquiv,
-}
-
-#[pymethods]
-impl Specialization {
-    fn __reduce__(&self, py: Python) -> PyResult<Py<PyAny>> {
-        // Ideally we'd use the string-only form of `__reduce__` for simplicity, but PyO3 enums
-        // don't produce Python singletons, and pickle doesn't like that.
-        let val: u8 = match self {
-            Self::General => 0,
-            Self::IdEquiv => 1,
-            Self::SWAPEquiv => 2,
-            Self::PartialSWAPEquiv => 3,
-            Self::PartialSWAPFlipEquiv => 4,
-            Self::ControlledEquiv => 5,
-            Self::MirrorControlledEquiv => 6,
-            Self::fSimaabEquiv => 7,
-            Self::fSimabbEquiv => 8,
-            Self::fSimabmbEquiv => 9,
-        };
-        Ok((py.get_type::<Self>().getattr("_from_u8")?, (val,)).into_py(py))
-    }
-
-    #[staticmethod]
-    fn _from_u8(val: u8) -> PyResult<Self> {
-        match val {
-            0 => Ok(Self::General),
-            1 => Ok(Self::IdEquiv),
-            2 => Ok(Self::SWAPEquiv),
-            3 => Ok(Self::PartialSWAPEquiv),
-            4 => Ok(Self::PartialSWAPFlipEquiv),
-            5 => Ok(Self::ControlledEquiv),
-            6 => Ok(Self::MirrorControlledEquiv),
-            7 => Ok(Self::fSimaabEquiv),
-            8 => Ok(Self::fSimabbEquiv),
-            9 => Ok(Self::fSimabmbEquiv),
-            x => Err(PyValueError::new_err(format!(
-                "unknown specialization discriminant '{x}'"
-            ))),
-        }
-    }
-}
-
-#[derive(Clone, Debug)]
-#[allow(non_snake_case)]
-#[pyclass(module = "qiskit._accelerate.two_qubit_decompose", subclass)]
-pub struct TwoQubitWeylDecomposition {
-    #[pyo3(get)]
-    a: f64,
-    #[pyo3(get)]
-    b: f64,
-    #[pyo3(get)]
-    c: f64,
-    #[pyo3(get)]
-    global_phase: f64,
-    K1l: Array2<Complex64>,
-    K2l: Array2<Complex64>,
-    K1r: Array2<Complex64>,
-    K2r: Array2<Complex64>,
-    #[pyo3(get)]
-    specialization: Specialization,
-    default_euler_basis: EulerBasis,
-    #[pyo3(get)]
-    requested_fidelity: Option<f64>,
-    #[pyo3(get)]
-    calculated_fidelity: f64,
-    unitary_matrix: Array2<Complex64>,
-}
-
-impl TwoQubitWeylDecomposition {
-    fn weyl_gate(
-        &self,
-        simplify: bool,
-        sequence: &mut TwoQubitSequenceVec,
-        atol: f64,
-        global_phase: &mut f64,
-    ) {
-        match self.specialization {
-            Specialization::MirrorControlledEquiv => {
-                sequence.push(("swap".to_string(), SmallVec::new(), smallvec![0, 1]));
-                sequence.push((
-                    "rzz".to_string(),
-                    smallvec![(PI4 - self.c) * 2.],
-                    smallvec![0, 1],
-                ));
-                *global_phase += PI4
-            }
-            Specialization::SWAPEquiv => {
-                sequence.push(("swap".to_string(), SmallVec::new(), smallvec![0, 1]));
-                *global_phase -= 3. * PI / 4.
-            }
-            _ => {
-                if !simplify || self.a.abs() > atol {
-                    sequence.push(("rxx".to_string(), smallvec![-self.a * 2.], smallvec![0, 1]));
-                }
-                if !simplify || self.b.abs() > atol {
-                    sequence.push(("ryy".to_string(), smallvec![-self.b * 2.], smallvec![0, 1]));
-                }
-                if !simplify || self.c.abs() > atol {
-                    sequence.push(("rzz".to_string(), smallvec![-self.c * 2.], smallvec![0, 1]));
-                }
-            }
-        }
-    }
-}
-
-const IPZ: [[Complex64; 2]; 2] = [
-    [C1_IM, Complex64::new(0., 0.)],
-    [Complex64::new(0., 0.), Complex64::new(0., -1.)],
-];
-const IPY: [[Complex64; 2]; 2] = [
-    [Complex64::new(0., 0.), Complex64::new(1., 0.)],
-    [Complex64::new(-1., 0.), Complex64::new(0., 0.)],
-];
-const IPX: [[Complex64; 2]; 2] = [
-    [Complex64::new(0., 0.), C1_IM],
-    [C1_IM, Complex64::new(0., 0.)],
-];
-
-#[pymethods]
-impl TwoQubitWeylDecomposition {
-    #[staticmethod]
-    fn _from_state(
-        angles: [f64; 4],
-        matrices: [PyReadonlyArray2<Complex64>; 5],
-        specialization: Specialization,
-        default_euler_basis: EulerBasis,
-        calculated_fidelity: f64,
-        requested_fidelity: Option<f64>,
-    ) -> Self {
-        let [a, b, c, global_phase] = angles;
-        Self {
-            a,
-            b,
-            c,
-            global_phase,
-            K1l: matrices[0].as_array().to_owned(),
-            K1r: matrices[1].as_array().to_owned(),
-            K2l: matrices[2].as_array().to_owned(),
-            K2r: matrices[3].as_array().to_owned(),
-            specialization,
-            default_euler_basis,
-            calculated_fidelity,
-            requested_fidelity,
-            unitary_matrix: matrices[4].as_array().to_owned(),
-        }
-    }
-
-    fn __reduce__(&self, py: Python) -> PyResult<Py<PyAny>> {
-        Ok((
-            py.get_type::<Self>().getattr("_from_state")?,
-            (
-                [self.a, self.b, self.c, self.global_phase],
-                [
-                    self.K1l.to_pyarray(py),
-                    self.K1r.to_pyarray(py),
-                    self.K2l.to_pyarray(py),
-                    self.K2r.to_pyarray(py),
-                    self.unitary_matrix.to_pyarray(py),
-                ],
-                self.specialization,
-                self.default_euler_basis,
-                self.calculated_fidelity,
-                self.requested_fidelity,
-            ),
-        )
-            .into_py(py))
-    }
-
-    #[new]
-    #[pyo3(signature=(unitary_matrix, fidelity=DEFAULT_FIDELITY, _specialization=None))]
-    fn new(
-        unitary_matrix: PyReadonlyArray2<Complex64>,
-        fidelity: Option<f64>,
-        _specialization: Option<Specialization>,
-    ) -> PyResult<Self> {
-        let ipz: ArrayView2<Complex64> = aview2(&IPZ);
-        let ipy: ArrayView2<Complex64> = aview2(&IPY);
-        let ipx: ArrayView2<Complex64> = aview2(&IPX);
-
-        let mut u = unitary_matrix.as_array().to_owned();
-        let unitary_matrix = unitary_matrix.as_array().to_owned();
-        let det_u = u.view().into_faer_complex().determinant().to_num_complex();
-        let det_pow = det_u.powf(-0.25);
-        u.mapv_inplace(|x| x * det_pow);
-        let mut global_phase = det_u.arg() / 4.;
-        let u_p = magic_basis_transform(u.view(), MagicBasisTransform::OutOf);
-        let m2 = u_p.t().dot(&u_p);
-        let default_euler_basis = EulerBasis::ZYZ;
-
-        // M2 is a symmetric complex matrix. We need to decompose it as M2 = P D P^T where
-        // P ∈ SO(4), D is diagonal with unit-magnitude elements.
-        //
-        // We can't use raw `eig` directly because it isn't guaranteed to give us real or othogonal
-        // eigenvectors. Instead, since `M2` is complex-symmetric,
-        //   M2 = A + iB
-        // for real-symmetric `A` and `B`, and as
-        //   M2^+ @ M2 = A^2 + B^2 + i [A, B] = 1
-        // we must have `A` and `B` commute, and consequently they are simultaneously diagonalizable.
-        // Mixing them together _should_ account for any degeneracy problems, but it's not
-        // guaranteed, so we repeat it a little bit.  The fixed seed is to make failures
-        // deterministic; the value is not important.
-        let mut state = Pcg64Mcg::seed_from_u64(2023);
-        let mut found = false;
-        let mut d: Array1<Complex64> = Array1::zeros(0);
-        let mut p: Array2<Complex64> = Array2::zeros((0, 0));
-        for i in 0..100 {
-            let rand_a: f64;
-            let rand_b: f64;
-            // For debugging the algorithm use the same RNG values from the
-            // previous Python implementation for the first random trial.
-            // In most cases this loop only executes a single iteration and
-            // using the same rng values rules out possible RNG differences
-            // as the root cause of a test failure
-            if i == 0 {
-                rand_a = 1.2602066112249388;
-                rand_b = 0.22317849046722027;
-            } else {
-                rand_a = state.sample(StandardNormal);
-                rand_b = state.sample(StandardNormal);
-            }
-            let m2_real = m2.mapv(|val| rand_a * val.re + rand_b * val.im);
-            let p_inner = m2_real
-                .view()
-                .into_faer()
-                .selfadjoint_eigendecomposition(Lower)
-                .u()
-                .into_ndarray()
-                .mapv(Complex64::from);
-            let d_inner = p_inner.t().dot(&m2).dot(&p_inner).diag().to_owned();
-            let mut diag_d: Array2<Complex64> = Array2::zeros((4, 4));
-            diag_d
-                .diag_mut()
-                .iter_mut()
-                .enumerate()
-                .for_each(|(index, x)| *x = d_inner[index]);
-
-            let compare = p_inner.dot(&diag_d).dot(&p_inner.t());
-            found = abs_diff_eq!(compare.view(), m2, epsilon = 1.0e-13);
-            if found {
-                p = p_inner;
-                d = d_inner;
-                break;
-            }
-        }
-        if !found {
-            import_exception!(qiskit, QiskitError);
-            return Err(QiskitError::new_err(format!(
-                "TwoQubitWeylDecomposition: failed to diagonalize M2. Please report this at https://github.com/Qiskit/qiskit-terra/issues/4159. Input: {:?}", unitary_matrix
-            )));
-        }
-        let mut d = -d.map(|x| x.arg() / 2.);
-        d[3] = -d[0] - d[1] - d[2];
-        let mut cs: SmallVec<[f64; 3]> = (0..3)
-            .map(|i| ((d[i] + d[3]) / 2.0).rem_euclid(TWO_PI))
-            .collect();
-        let cstemp: SmallVec<[f64; 3]> = cs
-            .iter()
-            .map(|x| x.rem_euclid(PI2))
-            .map(|x| x.min(PI2 - x))
-            .collect();
-        let mut order = utils::arg_sort(&cstemp);
-        (order[0], order[1], order[2]) = (order[1], order[2], order[0]);
-        (cs[0], cs[1], cs[2]) = (cs[order[0]], cs[order[1]], cs[order[2]]);
-        (d[0], d[1], d[2]) = (d[order[0]], d[order[1]], d[order[2]]);
-        let mut p_orig = p.clone();
-        for (i, item) in order.iter().enumerate().take(3) {
-            let slice_a = p.slice_mut(s![.., i]);
-            let slice_b = p_orig.slice_mut(s![.., *item]);
-            Zip::from(slice_a).and(slice_b).for_each(::std::mem::swap);
-        }
-        if p.view().into_faer_complex().determinant().re < 0. {
-            p.slice_mut(s![.., -1]).mapv_inplace(|x| -x);
-        }
-        let mut temp: Array2<Complex64> = Array2::zeros((4, 4));
-        temp.diag_mut()
-            .iter_mut()
-            .enumerate()
-            .for_each(|(index, x)| *x = (C1_IM * d[index]).exp());
-        let k1 = magic_basis_transform(u_p.dot(&p).dot(&temp).view(), MagicBasisTransform::Into);
-        let k2 = magic_basis_transform(p.t(), MagicBasisTransform::Into);
-
-        #[allow(non_snake_case)]
-        let (mut K1l, mut K1r, phase_l) = decompose_two_qubit_product_gate(k1.view())?;
-        #[allow(non_snake_case)]
-        let (K2l, mut K2r, phase_r) = decompose_two_qubit_product_gate(k2.view())?;
-        global_phase += phase_l + phase_r;
-
-        // Flip into Weyl chamber
-        if cs[0] > PI2 {
-            cs[0] -= PI32;
-            K1l = K1l.dot(&ipy);
-            K1r = K1r.dot(&ipy);
-            global_phase += PI2;
-        }
-        if cs[1] > PI2 {
-            cs[1] -= PI32;
-            K1l = K1l.dot(&ipx);
-            K1r = K1r.dot(&ipx);
-            global_phase += PI2;
-        }
-        let mut conjs = 0;
-        if cs[0] > PI4 {
-            cs[0] = PI2 - cs[0];
-            K1l = K1l.dot(&ipy);
-            K2r = ipy.dot(&K2r);
-            conjs += 1;
-            global_phase -= PI2;
-        }
-        if cs[1] > PI4 {
-            cs[1] = PI2 - cs[1];
-            K1l = K1l.dot(&ipx);
-            K2r = ipx.dot(&K2r);
-            conjs += 1;
-            global_phase += PI2;
-            if conjs == 1 {
-                global_phase -= PI;
-            }
-        }
-        if cs[2] > PI2 {
-            cs[2] -= PI32;
-            K1l = K1l.dot(&ipz);
-            K1r = K1r.dot(&ipz);
-            global_phase += PI2;
-            if conjs == 1 {
-                global_phase -= PI;
-            }
-        }
-        if conjs == 1 {
-            cs[2] = PI2 - cs[2];
-            K1l = K1l.dot(&ipz);
-            K2r = ipz.dot(&K2r);
-            global_phase += PI2;
-        }
-        if cs[2] > PI4 {
-            cs[2] -= PI2;
-            K1l = K1l.dot(&ipz);
-            K1r = K1r.dot(&ipz);
-            global_phase -= PI2;
-        }
-        let [a, b, c] = [cs[1], cs[0], cs[2]];
-        let is_close = |ap: f64, bp: f64, cp: f64| -> bool {
-            let [da, db, dc] = [a - ap, b - bp, c - cp];
-            let tr = 4.
-                * Complex64::new(
-                    da.cos() * db.cos() * dc.cos(),
-                    da.sin() * db.sin() * dc.sin(),
-                );
-            match fidelity {
-                Some(fid) => tr.trace_to_fid() >= fid,
-                // Set to false here to default to general specialization in the absence of a
-                // fidelity and provided specialization.
-                None => false,
-            }
-        };
-
-        let closest_abc = closest_partial_swap(a, b, c);
-        let closest_ab_minus_c = closest_partial_swap(a, b, -c);
-        let mut flipped_from_original = false;
-        let specialization = match _specialization {
-            Some(specialization) => specialization,
-            None => {
-                if is_close(0., 0., 0.) {
-                    Specialization::IdEquiv
-                } else if is_close(PI4, PI4, PI4) || is_close(PI4, PI4, -PI4) {
-                    Specialization::SWAPEquiv
-                } else if is_close(closest_abc, closest_abc, closest_abc) {
-                    Specialization::PartialSWAPEquiv
-                } else if is_close(closest_ab_minus_c, closest_ab_minus_c, -closest_ab_minus_c) {
-                    Specialization::PartialSWAPFlipEquiv
-                } else if is_close(a, 0., 0.) {
-                    Specialization::ControlledEquiv
-                } else if is_close(PI4, PI4, c) {
-                    Specialization::MirrorControlledEquiv
-                } else if is_close((a + b) / 2., (a + b) / 2., c) {
-                    Specialization::fSimaabEquiv
-                } else if is_close(a, (b + c) / 2., (b + c) / 2.) {
-                    Specialization::fSimabbEquiv
-                } else if is_close(a, (b - c) / 2., (c - b) / 2.) {
-                    Specialization::fSimabmbEquiv
-                } else {
-                    Specialization::General
-                }
-            }
-        };
-        let general = TwoQubitWeylDecomposition {
-            a,
-            b,
-            c,
-            global_phase,
-            K1l,
-            K1r,
-            K2l,
-            K2r,
-            specialization: Specialization::General,
-            default_euler_basis,
-            requested_fidelity: fidelity,
-            calculated_fidelity: -1.0,
-            unitary_matrix,
-        };
-        let mut specialized: TwoQubitWeylDecomposition = match specialization {
-            // :math:`U \sim U_d(0,0,0) \sim Id`
-            //
-            // This gate binds 0 parameters, we make it canonical by setting
-            // :math:`K2_l = Id` , :math:`K2_r = Id`.
-            Specialization::IdEquiv => TwoQubitWeylDecomposition {
-                specialization,
-                a: 0.,
-                b: 0.,
-                c: 0.,
-                K1l: general.K1l.dot(&general.K2l),
-                K1r: general.K1r.dot(&general.K2r),
-                K2l: Array2::eye(2),
-                K2r: Array2::eye(2),
-                ..general
-            },
-            // :math:`U \sim U_d(\pi/4, \pi/4, \pi/4) \sim U(\pi/4, \pi/4, -\pi/4) \sim \text{SWAP}`
-            //
-            // This gate binds 0 parameters, we make it canonical by setting
-            // :math:`K2_l = Id` , :math:`K2_r = Id`.
-            Specialization::SWAPEquiv => {
-                if c > 0. {
-                    TwoQubitWeylDecomposition {
-                        specialization,
-                        a: PI4,
-                        b: PI4,
-                        c: PI4,
-                        K1l: general.K1l.dot(&general.K2r),
-                        K1r: general.K1r.dot(&general.K2l),
-                        K2l: Array2::eye(2),
-                        K2r: Array2::eye(2),
-                        ..general
-                    }
-                } else {
-                    flipped_from_original = true;
-                    TwoQubitWeylDecomposition {
-                        specialization,
-                        a: PI4,
-                        b: PI4,
-                        c: PI4,
-                        global_phase: global_phase + PI2,
-                        K1l: general.K1l.dot(&ipz).dot(&general.K2r),
-                        K1r: general.K1r.dot(&ipz).dot(&general.K2l),
-                        K2l: Array2::eye(2),
-                        K2r: Array2::eye(2),
-                        ..general
-                    }
-                }
-            }
-            // :math:`U \sim U_d(\alpha\pi/4, \alpha\pi/4, \alpha\pi/4) \sim \text{SWAP}^\alpha`
-            //
-            // This gate binds 3 parameters, we make it canonical by setting:
-            //
-            // :math:`K2_l = Id`.
-            Specialization::PartialSWAPEquiv => {
-                let closest = closest_partial_swap(a, b, c);
-                let mut k2l_dag = general.K2l.t().to_owned();
-                k2l_dag.view_mut().mapv_inplace(|x| x.conj());
-                TwoQubitWeylDecomposition {
-                    specialization,
-                    a: closest,
-                    b: closest,
-                    c: closest,
-                    K1l: general.K1l.dot(&general.K2l),
-                    K1r: general.K1r.dot(&general.K2l),
-                    K2r: k2l_dag.dot(&general.K2r),
-                    K2l: Array2::eye(2),
-                    ..general
-                }
-            }
-            // :math:`U \sim U_d(\alpha\pi/4, \alpha\pi/4, -\alpha\pi/4) \sim \text{SWAP}^\alpha`
-            //
-            // (a non-equivalent root of SWAP from the TwoQubitWeylPartialSWAPEquiv
-            // similar to how :math:`x = (\pm \sqrt(x))^2`)
-            //
-            // This gate binds 3 parameters, we make it canonical by setting:
-            //
-            // :math:`K2_l = Id`
-            Specialization::PartialSWAPFlipEquiv => {
-                let closest = closest_partial_swap(a, b, -c);
-                let mut k2l_dag = general.K2l.t().to_owned();
-                k2l_dag.mapv_inplace(|x| x.conj());
-                TwoQubitWeylDecomposition {
-                    specialization,
-                    a: closest,
-                    b: closest,
-                    c: -closest,
-                    K1l: general.K1l.dot(&general.K2l),
-                    K1r: general.K1r.dot(&ipz).dot(&general.K2l).dot(&ipz),
-                    K2r: ipz.dot(&k2l_dag).dot(&ipz).dot(&general.K2r),
-                    K2l: Array2::eye(2),
-                    ..general
-                }
-            }
-            // :math:`U \sim U_d(\alpha, 0, 0) \sim \text{Ctrl-U}`
-            //
-            // This gate binds 4 parameters, we make it canonical by setting:
-            //
-            //      :math:`K2_l = Ry(\theta_l) Rx(\lambda_l)` ,
-            //      :math:`K2_r = Ry(\theta_r) Rx(\lambda_r)` .
-            Specialization::ControlledEquiv => {
-                let euler_basis = EulerBasis::XYX;
-                let [k2ltheta, k2lphi, k2llambda, k2lphase] =
-                    angles_from_unitary(general.K2l.view(), euler_basis);
-                let [k2rtheta, k2rphi, k2rlambda, k2rphase] =
-                    angles_from_unitary(general.K2r.view(), euler_basis);
-                TwoQubitWeylDecomposition {
-                    specialization,
-                    a,
-                    b: 0.,
-                    c: 0.,
-                    global_phase: global_phase + k2lphase + k2rphase,
-                    K1l: general.K1l.dot(&rx_matrix(k2lphi)),
-                    K1r: general.K1r.dot(&rx_matrix(k2rphi)),
-                    K2l: ry_matrix(k2ltheta).dot(&rx_matrix(k2llambda)),
-                    K2r: ry_matrix(k2rtheta).dot(&rx_matrix(k2rlambda)),
-                    default_euler_basis: euler_basis,
-                    ..general
-                }
-            }
-            // :math:`U \sim U_d(\pi/4, \pi/4, \alpha) \sim \text{SWAP} \cdot \text{Ctrl-U}`
-            //
-            // This gate binds 4 parameters, we make it canonical by setting:
-            //
-            // :math:`K2_l = Ry(\theta_l)\cdot Rz(\lambda_l)` , :math:`K2_r = Ry(\theta_r)\cdot Rz(\lambda_r)`
-            Specialization::MirrorControlledEquiv => {
-                let [k2ltheta, k2lphi, k2llambda, k2lphase] =
-                    angles_from_unitary(general.K2l.view(), EulerBasis::ZYZ);
-                let [k2rtheta, k2rphi, k2rlambda, k2rphase] =
-                    angles_from_unitary(general.K2r.view(), EulerBasis::ZYZ);
-                TwoQubitWeylDecomposition {
-                    specialization,
-                    a: PI4,
-                    b: PI4,
-                    c,
-                    global_phase: global_phase + k2lphase + k2rphase,
-                    K1l: general.K1l.dot(&rz_matrix(k2rphi)),
-                    K1r: general.K1r.dot(&rz_matrix(k2lphi)),
-                    K2l: ry_matrix(k2ltheta).dot(&rz_matrix(k2llambda)),
-                    K2r: ry_matrix(k2rtheta).dot(&rz_matrix(k2rlambda)),
-                    ..general
-                }
-            }
-            // :math:`U \sim U_d(\alpha, \alpha, \beta), \alpha \geq |\beta|`
-            //
-            // This gate binds 5 parameters, we make it canonical by setting:
-            //
-            // :math:`K2_l = Ry(\theta_l)\cdot Rz(\lambda_l)`.
-            Specialization::fSimaabEquiv => {
-                let [k2ltheta, k2lphi, k2llambda, k2lphase] =
-                    angles_from_unitary(general.K2l.view(), EulerBasis::ZYZ);
-                TwoQubitWeylDecomposition {
-                    specialization,
-                    a: (a + b) / 2.,
-                    b: (a + b) / 2.,
-                    c,
-                    global_phase: global_phase + k2lphase,
-                    K1r: general.K1r.dot(&rz_matrix(k2lphi)),
-                    K1l: general.K1l.dot(&rz_matrix(k2lphi)),
-                    K2l: ry_matrix(k2ltheta).dot(&rz_matrix(k2llambda)),
-                    K2r: rz_matrix(-k2lphi).dot(&general.K2r),
-                    ..general
-                }
-            }
-            // :math:`U \sim U_d(\alpha, \beta, -\beta), \alpha \geq \beta \geq 0`
-            //
-            // This gate binds 5 parameters, we make it canonical by setting:
-            //
-            // :math:`K2_l = Ry(\theta_l)Rx(\lambda_l)`
-            Specialization::fSimabbEquiv => {
-                let euler_basis = EulerBasis::XYX;
-                let [k2ltheta, k2lphi, k2llambda, k2lphase] =
-                    angles_from_unitary(general.K2l.view(), euler_basis);
-                TwoQubitWeylDecomposition {
-                    specialization,
-                    a,
-                    b: (b + c) / 2.,
-                    c: (b + c) / 2.,
-                    global_phase: global_phase + k2lphase,
-                    K1r: general.K1r.dot(&rx_matrix(k2lphi)),
-                    K1l: general.K1l.dot(&rx_matrix(k2lphi)),
-                    K2l: ry_matrix(k2ltheta).dot(&rx_matrix(k2llambda)),
-                    K2r: rx_matrix(-k2lphi).dot(&general.K2r),
-                    default_euler_basis: euler_basis,
-                    ..general
-                }
-            }
-            // :math:`U \sim U_d(\alpha, \beta, -\beta), \alpha \geq \beta \geq 0`
-            //
-            // This gate binds 5 parameters, we make it canonical by setting:
-            //
-            // :math:`K2_l = Ry(\theta_l)Rx(\lambda_l)`
-            Specialization::fSimabmbEquiv => {
-                let euler_basis = EulerBasis::XYX;
-                let [k2ltheta, k2lphi, k2llambda, k2lphase] =
-                    angles_from_unitary(general.K2l.view(), euler_basis);
-                TwoQubitWeylDecomposition {
-                    specialization,
-                    a,
-                    b: (b - c) / 2.,
-                    c: -((b - c) / 2.),
-                    global_phase: global_phase + k2lphase,
-                    K1l: general.K1l.dot(&rx_matrix(k2lphi)),
-                    K1r: general.K1r.dot(&ipz).dot(&rx_matrix(k2lphi)).dot(&ipz),
-                    K2l: ry_matrix(k2ltheta).dot(&rx_matrix(k2llambda)),
-                    K2r: ipz.dot(&rx_matrix(-k2lphi)).dot(&ipz).dot(&general.K2r),
-                    default_euler_basis: euler_basis,
-                    ..general
-                }
-            }
-            // U has no special symmetry.
-            //
-            // This gate binds all 6 possible parameters, so there is no need to make the single-qubit
-            // pre-/post-gates canonical.
-            Specialization::General => general,
-        };
-
-        let tr = if flipped_from_original {
-            let [da, db, dc] = [
-                PI2 - a - specialized.a,
-                b - specialized.b,
-                -c - specialized.c,
-            ];
-            4. * Complex64::new(
-                da.cos() * db.cos() * dc.cos(),
-                da.sin() * db.sin() * dc.sin(),
-            )
-        } else {
-            let [da, db, dc] = [a - specialized.a, b - specialized.b, c - specialized.c];
-            4. * Complex64::new(
-                da.cos() * db.cos() * dc.cos(),
-                da.sin() * db.sin() * dc.sin(),
-            )
-        };
-        specialized.calculated_fidelity = tr.trace_to_fid();
-        if let Some(fid) = specialized.requested_fidelity {
-            if specialized.calculated_fidelity + 1.0e-13 < fid {
-                import_exception!(qiskit, QiskitError);
-                return Err(QiskitError::new_err(format!(
-                    "Specialization: {:?} calculated fidelity: {} is worse than requested fidelity: {}",
-                    specialized.specialization,
-                    specialized.calculated_fidelity,
-                    fid
-                )));
-            }
-        }
-        specialized.global_phase += tr.arg();
-        Ok(specialized)
-    }
-
-    #[allow(non_snake_case)]
-    #[getter]
-    fn K1l(&self, py: Python) -> PyObject {
-        self.K1l.to_pyarray(py).into()
-    }
-
-    #[allow(non_snake_case)]
-    #[getter]
-    fn K1r(&self, py: Python) -> PyObject {
-        self.K1r.to_pyarray(py).into()
-    }
-
-    #[allow(non_snake_case)]
-    #[getter]
-    fn K2l(&self, py: Python) -> PyObject {
-        self.K2l.to_pyarray(py).into()
-    }
-
-    #[allow(non_snake_case)]
-    #[getter]
-    fn K2r(&self, py: Python) -> PyObject {
-        self.K2r.to_pyarray(py).into()
-    }
-
-    #[getter]
-    fn unitary_matrix(&self, py: Python) -> PyObject {
-        self.unitary_matrix.to_pyarray(py).into()
-    }
-
-    #[pyo3(signature = (euler_basis=None, simplify=false, atol=None))]
-    fn circuit(
-        &self,
-        euler_basis: Option<&str>,
-        simplify: bool,
-        atol: Option<f64>,
-    ) -> PyResult<TwoQubitGateSequence> {
-        let euler_basis: EulerBasis = match euler_basis {
-            Some(basis) => EulerBasis::from_str(basis)?,
-            None => self.default_euler_basis,
-        };
-        let target_1q_basis_list: Vec<EulerBasis> = vec![euler_basis];
-
-        let mut gate_sequence = Vec::new();
-        let mut global_phase: f64 = self.global_phase;
-
-        let c2r = unitary_to_gate_sequence_inner(
-            self.K2r.view(),
-            &target_1q_basis_list,
-            0,
-            None,
-            simplify,
-            atol,
-        )
-        .unwrap();
-        for gate in c2r.gates {
-            gate_sequence.push((gate.0, gate.1, smallvec![0]))
-        }
-        global_phase += c2r.global_phase;
-        let c2l = unitary_to_gate_sequence_inner(
-            self.K2l.view(),
-            &target_1q_basis_list,
-            1,
-            None,
-            simplify,
-            atol,
-        )
-        .unwrap();
-        for gate in c2l.gates {
-            gate_sequence.push((gate.0, gate.1, smallvec![1]))
-        }
-        global_phase += c2l.global_phase;
-        self.weyl_gate(
-            simplify,
-            &mut gate_sequence,
-            atol.unwrap_or(ANGLE_ZERO_EPSILON),
-            &mut global_phase,
-        );
-        let c1r = unitary_to_gate_sequence_inner(
-            self.K1r.view(),
-            &target_1q_basis_list,
-            0,
-            None,
-            simplify,
-            atol,
-        )
-        .unwrap();
-        for gate in c1r.gates {
-            gate_sequence.push((gate.0, gate.1, smallvec![0]))
-        }
-        global_phase += c2r.global_phase;
-        let c1l = unitary_to_gate_sequence_inner(
-            self.K1l.view(),
-            &target_1q_basis_list,
-            1,
-            None,
-            simplify,
-            atol,
-        )
-        .unwrap();
-        for gate in c1l.gates {
-            gate_sequence.push((gate.0, gate.1, smallvec![1]))
-        }
-        Ok(TwoQubitGateSequence {
-            gates: gate_sequence,
-            global_phase,
-        })
-    }
-}
-
-type TwoQubitSequenceVec = Vec<(String, SmallVec<[f64; 3]>, SmallVec<[u8; 2]>)>;
-
-#[pyclass(sequence)]
-pub struct TwoQubitGateSequence {
-    gates: TwoQubitSequenceVec,
-    #[pyo3(get)]
-    global_phase: f64,
-}
-
-#[pymethods]
-impl TwoQubitGateSequence {
-    #[new]
-    fn new() -> Self {
-        TwoQubitGateSequence {
-            gates: Vec::new(),
-            global_phase: 0.,
-        }
-    }
-
-    fn __getstate__(&self) -> (TwoQubitSequenceVec, f64) {
-        (self.gates.clone(), self.global_phase)
-    }
-
-    fn __setstate__(&mut self, state: (TwoQubitSequenceVec, f64)) {
-        self.gates = state.0;
-        self.global_phase = state.1;
-    }
-
-    fn __len__(&self) -> PyResult<usize> {
-        Ok(self.gates.len())
-    }
-
-    fn __getitem__(&self, py: Python, idx: utils::SliceOrInt) -> PyResult<PyObject> {
-        match idx {
-            utils::SliceOrInt::Slice(slc) => {
-                let len = self.gates.len().try_into().unwrap();
-                let indices = slc.indices(len)?;
-                let mut out_vec: TwoQubitSequenceVec = Vec::new();
-                // Start and stop will always be positive the slice api converts
-                // negatives to the index for example:
-                // list(range(5))[-1:-3:-1]
-                // will return start=4, stop=2, and step=-
-                let mut pos: isize = indices.start;
-                let mut cond = if indices.step < 0 {
-                    pos > indices.stop
-                } else {
-                    pos < indices.stop
-                };
-                while cond {
-                    if pos < len as isize {
-                        out_vec.push(self.gates[pos as usize].clone());
-                    }
-                    pos += indices.step;
-                    if indices.step < 0 {
-                        cond = pos > indices.stop;
-                    } else {
-                        cond = pos < indices.stop;
-                    }
-                }
-                Ok(out_vec.into_py(py))
-            }
-            utils::SliceOrInt::Int(idx) => {
-                let len = self.gates.len() as isize;
-                if idx >= len || idx < -len {
-                    Err(PyIndexError::new_err(format!("Invalid index, {idx}")))
-                } else if idx < 0 {
-                    let len = self.gates.len();
-                    Ok(self.gates[len - idx.unsigned_abs()].to_object(py))
-                } else {
-                    Ok(self.gates[idx as usize].to_object(py))
-                }
-            }
-        }
-    }
+/// Average gate fidelity is :math:`Fbar = (d + |Tr (Utarget \\cdot U^dag)|^2) / d(d+1)`
+/// M. Horodecki, P. Horodecki and R. Horodecki, PRA 60, 1888 (1999)
+fn trace_to_fid(trace: &c64) -> f64 {
+    (4.0 + trace.faer_abs2()) / 20.0
 }
 
 #[pymodule]
 pub fn two_qubit_decompose(_py: Python, m: &PyModule) -> PyResult<()> {
     m.add_wrapped(wrap_pyfunction!(_num_basis_gates))?;
-    m.add_class::<TwoQubitGateSequence>()?;
-    m.add_class::<TwoQubitWeylDecomposition>()?;
-    m.add_class::<Specialization>()?;
     Ok(())
 }
diff --git a/qiskit/__init__.py b/qiskit/__init__.py
index 4d91f6d6e..782d8aaab 100644
--- a/qiskit/__init__.py
+++ b/qiskit/__init__.py
@@ -70,7 +70,6 @@ sys.modules["qiskit._accelerate.euler_one_qubit_decomposer"] = (
 sys.modules["qiskit._accelerate.convert_2q_block_matrix"] = (
     qiskit._accelerate.convert_2q_block_matrix
 )
-sys.modules["qiskit._accelerate.two_qubit_decompose"] = qiskit._accelerate.two_qubit_decompose
 
 # qiskit errors operator
 from qiskit.exceptions import QiskitError, MissingOptionalLibraryError
diff --git a/qiskit/compiler/transpiler.py b/qiskit/compiler/transpiler.py
index dd6758acc..9812d3143 100644
--- a/qiskit/compiler/transpiler.py
+++ b/qiskit/compiler/transpiler.py
@@ -24,6 +24,7 @@ from qiskit.circuit.quantumcircuit import QuantumCircuit
 from qiskit.circuit.quantumregister import Qubit
 from qiskit.dagcircuit import DAGCircuit
 from qiskit.providers.backend import Backend
+from qiskit.providers.backend_compat import BackendV2Converter
 from qiskit.providers.models import BackendProperties
 from qiskit.pulse import Schedule, InstructionScheduleMap
 from qiskit.transpiler import Layout, CouplingMap, PropertySet
@@ -33,7 +34,7 @@ from qiskit.transpiler.instruction_durations import InstructionDurations, Instru
 from qiskit.transpiler.passes.synthesis.high_level_synthesis import HLSConfig
 from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
 from qiskit.transpiler.timing_constraints import TimingConstraints
-from qiskit.transpiler.target import Target, target_to_backend_properties
+from qiskit.transpiler.target import Target, target_to_backend_properties, InstructionProperties
 
 logger = logging.getLogger(__name__)
 
@@ -293,6 +294,12 @@ def transpile(  # pylint: disable=too-many-return-statements
         config = user_config.get_config()
         optimization_level = config.get("transpile_optimization_level", 1)
 
+    if backend is not None and getattr(backend, "version", 0) <= 1:
+        # This is a temporary conversion step to allow for a smoother transition
+        # to a fully target-based transpiler pipeline while maintaining the behavior
+        # of `transpile` with BackendV1 inputs.
+        backend = BackendV2Converter(backend)
+
     if (
         scheduling_method is not None
         and backend is None
@@ -325,8 +332,14 @@ def transpile(  # pylint: disable=too-many-return-statements
             backend_properties = target_to_backend_properties(target)
     # If target is not specified and any hardware constraint object is
     # manually specified then do not use the target from the backend as
-    # it is invalidated by a custom basis gate list or a custom coupling map
-    elif basis_gates is not None or coupling_map is not None:
+    # it is invalidated by a custom basis gate list, custom coupling map,
+    # custom dt or custom instruction_durations
+    elif (
+        basis_gates is not None
+        or coupling_map is not None
+        or dt is not None
+        or instruction_durations is not None
+    ):
         _skip_target = True
     else:
         target = getattr(backend, "target", None)
@@ -440,14 +453,8 @@ def _check_circuits_coupling_map(circuits, cmap, backend):
     if cmap is not None:
         max_qubits = cmap.size()
     elif backend is not None:
-        backend_version = getattr(backend, "version", 0)
-        if backend_version <= 1:
-            if not backend.configuration().simulator:
-                max_qubits = backend.configuration().n_qubits
-            else:
-                max_qubits = None
-        else:
-            max_qubits = backend.num_qubits
+        max_qubits = backend.num_qubits
+
     for circuit in circuits:
         # If coupling_map is not None or num_qubits == 1
         num_qubits = len(circuit.qubits)
@@ -465,27 +472,15 @@ def _log_transpile_time(start_time, end_time):
 
 def _parse_inst_map(inst_map, backend):
     # try getting inst_map from user, else backend
-    if inst_map is None:
-        backend_version = getattr(backend, "version", 0)
-        if backend_version <= 1:
-            if hasattr(backend, "defaults"):
-                inst_map = getattr(backend.defaults(), "instruction_schedule_map", None)
-        else:
-            inst_map = backend.target.instruction_schedule_map()
+    if inst_map is None and backend is not None:
+        inst_map = backend.target.instruction_schedule_map()
     return inst_map
 
 
 def _parse_coupling_map(coupling_map, backend):
     # try getting coupling_map from user, else backend
-    if coupling_map is None:
-        backend_version = getattr(backend, "version", 0)
-        if backend_version <= 1:
-            if getattr(backend, "configuration", None):
-                configuration = backend.configuration()
-                if hasattr(configuration, "coupling_map") and configuration.coupling_map:
-                    coupling_map = CouplingMap(configuration.coupling_map)
-        else:
-            coupling_map = backend.coupling_map
+    if coupling_map is None and backend is not None:
+        coupling_map = backend.coupling_map
 
     # coupling_map could be None, or a list of lists, e.g. [[0, 1], [2, 1]]
     if coupling_map is None or isinstance(coupling_map, CouplingMap):
@@ -522,14 +517,8 @@ def _parse_instruction_durations(backend, inst_durations, dt, circuit):
     take precedence over backend durations, but be superceded by ``inst_duration``s.
     """
     if not inst_durations:
-        backend_version = getattr(backend, "version", 0)
-        if backend_version <= 1:
-            backend_durations = InstructionDurations()
-            try:
-                backend_durations = InstructionDurations.from_backend(backend)
-            except AttributeError:
-                pass
-        else:
+        backend_durations = InstructionDurations()
+        if backend is not None:
             backend_durations = backend.instruction_durations
 
     circ_durations = InstructionDurations()
@@ -598,13 +587,6 @@ def _parse_timing_constraints(backend, timing_constraints):
         return timing_constraints
     if backend is None and timing_constraints is None:
         timing_constraints = TimingConstraints()
-    else:
-        backend_version = getattr(backend, "version", 0)
-        if backend_version <= 1:
-            if timing_constraints is None:
-                # get constraints from backend
-                timing_constraints = getattr(backend.configuration(), "timing_constraints", {})
-            timing_constraints = TimingConstraints(**timing_constraints)
-        else:
-            timing_constraints = backend.target.timing_constraints()
+    elif backend is not None:
+        timing_constraints = backend.target.timing_constraints()
     return timing_constraints
diff --git a/qiskit/primitives/__init__.py b/qiskit/primitives/__init__.py
index dfc315676..cdfdde87a 100644
--- a/qiskit/primitives/__init__.py
+++ b/qiskit/primitives/__init__.py
@@ -387,15 +387,14 @@ level, however, here are some notable differences keep in mind when migrating fr
 Primitives API
 ==============
 
-Estimator V2
-------------
+Primitives V2
+-------------
 
 .. autosummary::
    :toctree: ../stubs/
 
    BaseEstimatorV2
    StatevectorEstimator
-   BackendEstimatorV2
 
 Sampler V2
 ----------
@@ -405,7 +404,6 @@ Sampler V2
 
    BaseSamplerV2
    StatevectorSampler
-   BackendSamplerV2
 
 Results V2
 ----------
@@ -475,5 +473,3 @@ from .primitive_job import BasePrimitiveJob, PrimitiveJob
 from .sampler import Sampler
 from .statevector_estimator import StatevectorEstimator
 from .statevector_sampler import StatevectorSampler
-from .backend_estimator_v2 import BackendEstimatorV2
-from .backend_sampler_v2 import BackendSamplerV2
diff --git a/qiskit/primitives/backend_estimator.py b/qiskit/primitives/backend_estimator.py
index 23556e2ef..50016dfe7 100644
--- a/qiskit/primitives/backend_estimator.py
+++ b/qiskit/primitives/backend_estimator.py
@@ -413,12 +413,14 @@ def _paulis2inds(paulis: PauliList) -> list[int]:
     # Treat Z, X, Y the same
     nonid = paulis.z | paulis.x
 
+    inds = [0] * paulis.size
     # bits are packed into uint8 in little endian
     # e.g., i-th bit corresponds to coefficient 2^i
     packed_vals = np.packbits(nonid, axis=1, bitorder="little")
-    power_uint8 = 1 << (8 * np.arange(packed_vals.shape[1], dtype=object))
-    inds = packed_vals @ power_uint8
-    return inds.tolist()
+    for i, vals in enumerate(packed_vals):
+        for j, val in enumerate(vals):
+            inds[i] += val.item() * (1 << (8 * j))
+    return inds
 
 
 def _parity(integer: int) -> int:
diff --git a/qiskit/primitives/backend_estimator_v2.py b/qiskit/primitives/backend_estimator_v2.py
deleted file mode 100644
index 91e45a16e..000000000
--- a/qiskit/primitives/backend_estimator_v2.py
+++ /dev/null
@@ -1,290 +0,0 @@
-# This code is part of Qiskit.
-#
-# (C) Copyright IBM 2024.
-#
-# This code is licensed under the Apache License, Version 2.0. You may
-# obtain a copy of this license in the LICENSE.txt file in the root directory
-# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
-#
-# Any modifications or derivative works of this code must retain this
-# copyright notice, and modified files need to carry a notice indicating
-# that they have been altered from the originals.
-
-"""Estimator V2 implementation for an arbitrary Backend object."""
-
-from __future__ import annotations
-
-from collections import defaultdict
-from collections.abc import Iterable
-from dataclasses import dataclass
-
-import numpy as np
-
-from qiskit.circuit import ClassicalRegister, QuantumCircuit, QuantumRegister
-from qiskit.exceptions import QiskitError
-from qiskit.providers import BackendV1, BackendV2
-from qiskit.quantum_info import Pauli, PauliList
-from qiskit.transpiler import PassManager, PassManagerConfig
-from qiskit.transpiler.passes import Optimize1qGatesDecomposition
-
-from .backend_estimator import _pauli_expval_with_variance, _prepare_counts, _run_circuits
-from .base import BaseEstimatorV2
-from .containers import EstimatorPubLike, PrimitiveResult, PubResult
-from .containers.bindings_array import BindingsArray
-from .containers.estimator_pub import EstimatorPub
-from .primitive_job import PrimitiveJob
-
-
-@dataclass
-class Options:
-    """Options for :class:`~.BackendEstimatorV2`."""
-
-    default_precision: float = 0.015625
-    """The default precision to use if none are specified in :meth:`~run`.
-    Default: 0.015625 (1 / sqrt(4096)).
-    """
-
-    abelian_grouping: bool = True
-    """Whether the observables should be grouped into sets of qubit-wise commuting observables.
-    Default: True.
-    """
-
-    seed_simulator: int | None = None
-    """The seed to use in the simulator. If None, a random seed will be used.
-    Default: None.
-    """
-
-
-class BackendEstimatorV2(BaseEstimatorV2):
-    """Evaluates expectation values for provided quantum circuit and observable combinations
-
-    The :class:`~.BackendEstimatorV2` class is a generic implementation of the
-    :class:`~.BaseEstimatorV2` interface that is used to wrap a :class:`~.BackendV2`
-    (or :class:`~.BackendV1`) object in the :class:`~.BaseEstimatorV2` API. It
-    facilitates using backends that do not provide a native
-    :class:`~.BaseEstimatorV2` implementation in places that work with
-    :class:`~.BaseEstimatorV2`. However,
-    if you're using a provider that has a native implementation of
-    :class:`~.BaseEstimatorV2`, it is a better choice to leverage that native
-    implementation as it will likely include additional optimizations and be
-    a more efficient implementation. The generic nature of this class
-    precludes doing any provider- or backend-specific optimizations.
-
-    This class does not perform any measurement or gate mitigation, and, presently, is only
-    compatible with Pauli-based observables.
-
-    Each tuple of ``(circuit, observables, <optional> parameter values, <optional> precision)``,
-    called an estimator primitive unified bloc (PUB), produces its own array-based result. The
-    :meth:`~.BackendEstimatorV2.run` method can be given a sequence of pubs to run in one call.
-
-    The options for :class:`~.BackendEstimatorV2` consist of the following items.
-
-    * ``default_precision``: The default precision to use if none are specified in :meth:`~run`.
-      Default: 0.015625 (1 / sqrt(4096)).
-
-    * ``abelian_grouping``: Whether the observables should be grouped into sets of qubit-wise
-      commuting observables.
-      Default: True.
-
-    * ``seed_simulator``: The seed to use in the simulator. If None, a random seed will be used.
-      Default: None.
-    """
-
-    def __init__(
-        self,
-        *,
-        backend: BackendV1 | BackendV2,
-        options: dict | None = None,
-    ):
-        """
-        Args:
-            backend: The backend to run the primitive on.
-            options: The options to control the default precision (``default_precision``),
-                the operator grouping (``abelian_grouping``), and
-                the random seed for the simulator (``seed_simulator``).
-        """
-        self._backend = backend
-        self._options = Options(**options) if options else Options()
-
-        basis = PassManagerConfig.from_backend(backend).basis_gates
-        if isinstance(backend, BackendV2):
-            opt1q = Optimize1qGatesDecomposition(basis=basis, target=backend.target)
-        else:
-            opt1q = Optimize1qGatesDecomposition(basis=basis)
-        self._passmanager = PassManager([opt1q])
-
-    @property
-    def options(self) -> Options:
-        """Return the options"""
-        return self._options
-
-    @property
-    def backend(self) -> BackendV1 | BackendV2:
-        """Returns the backend which this sampler object based on."""
-        return self._backend
-
-    def run(
-        self, pubs: Iterable[EstimatorPubLike], *, precision: float | None = None
-    ) -> PrimitiveJob[PrimitiveResult[PubResult]]:
-        if precision is None:
-            precision = self._options.default_precision
-        coerced_pubs = [EstimatorPub.coerce(pub, precision) for pub in pubs]
-        self._validate_pubs(coerced_pubs)
-        job = PrimitiveJob(self._run, coerced_pubs)
-        job._submit()
-        return job
-
-    def _validate_pubs(self, pubs: list[EstimatorPub]):
-        for i, pub in enumerate(pubs):
-            if pub.precision <= 0.0:
-                raise ValueError(
-                    f"The {i}-th pub has precision less than or equal to 0 ({pub.precision}). ",
-                    "But precision should be larger than 0.",
-                )
-
-    def _run(self, pubs: list[EstimatorPub]) -> PrimitiveResult[PubResult]:
-        return PrimitiveResult([self._run_pub(pub) for pub in pubs])
-
-    def _run_pub(self, pub: EstimatorPub) -> PubResult:
-        shots = int(np.ceil(1.0 / pub.precision**2))
-        circuit = pub.circuit
-        observables = pub.observables
-        parameter_values = pub.parameter_values
-
-        # calculate broadcasting of parameters and observables
-        param_shape = parameter_values.shape
-        param_indices = np.fromiter(np.ndindex(param_shape), dtype=object).reshape(param_shape)
-        bc_param_ind, bc_obs = np.broadcast_arrays(param_indices, observables)
-
-        # calculate expectation values for each pair of parameter value set and pauli
-        param_obs_map = defaultdict(set)
-        for index in np.ndindex(*bc_param_ind.shape):
-            param_index = bc_param_ind[index]
-            param_obs_map[param_index].update(bc_obs[index].keys())
-        expval_map = self._calc_expval_paulis(circuit, parameter_values, param_obs_map, shots)
-
-        # calculate expectation values (evs) and standard errors (stds)
-        evs = np.zeros_like(bc_param_ind, dtype=float)
-        variances = np.zeros_like(bc_param_ind, dtype=float)
-        for index in np.ndindex(*bc_param_ind.shape):
-            param_index = bc_param_ind[index]
-            for pauli, coeff in bc_obs[index].items():
-                expval, variance = expval_map[param_index, pauli]
-                evs[index] += expval * coeff
-                variances[index] += variance * coeff**2
-        stds = np.sqrt(variances / shots)
-        data_bin_cls = self._make_data_bin(pub)
-        data_bin = data_bin_cls(evs=evs, stds=stds)
-        return PubResult(data_bin, metadata={"target_precision": pub.precision})
-
-    def _calc_expval_paulis(
-        self,
-        circuit: QuantumCircuit,
-        parameter_values: BindingsArray,
-        param_obs_map: dict[tuple[int, ...], set[str]],
-        shots: int,
-    ) -> dict[tuple[tuple[int, ...], str], tuple[float, float]]:
-        # generate circuits
-        circuits = []
-        for param_index, pauli_strings in param_obs_map.items():
-            bound_circuit = parameter_values.bind(circuit, param_index)
-            # sort pauli_strings so that the order is deterministic
-            meas_paulis = PauliList(sorted(pauli_strings))
-            new_circuits = self._preprocessing(bound_circuit, meas_paulis, param_index)
-            circuits.extend(new_circuits)
-
-        # run circuits
-        result, metadata = _run_circuits(
-            circuits, self._backend, shots=shots, seed_simulator=self._options.seed_simulator
-        )
-
-        # postprocessing results
-        expval_map: dict[tuple[tuple[int, ...], str], tuple[float, float]] = {}
-        counts = _prepare_counts(result)
-        for count, meta in zip(counts, metadata):
-            orig_paulis = meta["orig_paulis"]
-            meas_paulis = meta["meas_paulis"]
-            param_index = meta["param_index"]
-            expvals, variances = _pauli_expval_with_variance(count, meas_paulis)
-            for pauli, expval, variance in zip(orig_paulis, expvals, variances):
-                expval_map[param_index, pauli.to_label()] = (expval, variance)
-        return expval_map
-
-    def _preprocessing(
-        self, circuit: QuantumCircuit, observable: PauliList, param_index: tuple[int, ...]
-    ) -> list[QuantumCircuit]:
-        # generate measurement circuits with metadata
-        meas_circuits: list[QuantumCircuit] = []
-        if self._options.abelian_grouping:
-            for obs in observable.group_commuting(qubit_wise=True):
-                basis = Pauli((np.logical_or.reduce(obs.z), np.logical_or.reduce(obs.x)))
-                meas_circuit, indices = _measurement_circuit(circuit.num_qubits, basis)
-                paulis = PauliList.from_symplectic(
-                    obs.z[:, indices],
-                    obs.x[:, indices],
-                    obs.phase,
-                )
-                meas_circuit.metadata = {
-                    "orig_paulis": obs,
-                    "meas_paulis": paulis,
-                    "param_index": param_index,
-                }
-                meas_circuits.append(meas_circuit)
-        else:
-            for basis in observable:
-                meas_circuit, indices = _measurement_circuit(circuit.num_qubits, basis)
-                obs = PauliList(basis)
-                paulis = PauliList.from_symplectic(
-                    obs.z[:, indices],
-                    obs.x[:, indices],
-                    obs.phase,
-                )
-                meas_circuit.metadata = {
-                    "orig_paulis": obs,
-                    "meas_paulis": paulis,
-                    "param_index": param_index,
-                }
-                meas_circuits.append(meas_circuit)
-
-        # unroll basis gates
-        meas_circuits = self._passmanager.run(meas_circuits)
-
-        # combine measurement circuits
-        preprocessed_circuits = []
-        for meas_circuit in meas_circuits:
-            circuit_copy = circuit.copy()
-            # meas_circuit is supposed to have a classical register whose name is different from
-            # those of the transpiled_circuit
-            clbits = meas_circuit.cregs[0]
-            for creg in circuit_copy.cregs:
-                if clbits.name == creg.name:
-                    raise QiskitError(
-                        "Classical register for measurements conflict with those of the input "
-                        f"circuit: {clbits}. "
-                        "Recommended to avoid register names starting with '__'."
-                    )
-            circuit_copy.add_register(clbits)
-            circuit_copy.compose(meas_circuit, clbits=clbits, inplace=True)
-            circuit_copy.metadata = meas_circuit.metadata
-            preprocessed_circuits.append(circuit_copy)
-        return preprocessed_circuits
-
-
-def _measurement_circuit(num_qubits: int, pauli: Pauli):
-    # Note: if pauli is I for all qubits, this function generates a circuit to measure only
-    # the first qubit.
-    # Although such an operator can be optimized out by interpreting it as a constant (1),
-    # this optimization requires changes in various methods. So it is left as future work.
-    qubit_indices = np.arange(pauli.num_qubits)[pauli.z | pauli.x]
-    if not np.any(qubit_indices):
-        qubit_indices = [0]
-    meas_circuit = QuantumCircuit(
-        QuantumRegister(num_qubits, "q"), ClassicalRegister(len(qubit_indices), f"__c_{pauli}")
-    )
-    for clbit, i in enumerate(qubit_indices):
-        if pauli.x[i]:
-            if pauli.z[i]:
-                meas_circuit.sdg(i)
-            meas_circuit.h(i)
-        meas_circuit.measure(i, clbit)
-    return meas_circuit, qubit_indices
diff --git a/qiskit/primitives/backend_sampler_v2.py b/qiskit/primitives/backend_sampler_v2.py
deleted file mode 100644
index ddd7b0b9b..000000000
--- a/qiskit/primitives/backend_sampler_v2.py
+++ /dev/null
@@ -1,233 +0,0 @@
-# This code is part of Qiskit.
-#
-# (C) Copyright IBM 2024.
-#
-# This code is licensed under the Apache License, Version 2.0. You may
-# obtain a copy of this license in the LICENSE.txt file in the root directory
-# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
-#
-# Any modifications or derivative works of this code must retain this
-# copyright notice, and modified files need to carry a notice indicating
-# that they have been altered from the originals.
-
-"""Sampler V2 implementation for an arbitrary Backend object."""
-
-from __future__ import annotations
-
-import warnings
-from dataclasses import dataclass
-from typing import Iterable
-
-import numpy as np
-from numpy.typing import NDArray
-
-from qiskit.circuit import QuantumCircuit
-from qiskit.primitives.backend_estimator import _run_circuits
-from qiskit.primitives.base import BaseSamplerV2
-from qiskit.primitives.containers import (
-    BitArray,
-    PrimitiveResult,
-    PubResult,
-    SamplerPubLike,
-    make_data_bin,
-)
-from qiskit.primitives.containers.bit_array import _min_num_bytes
-from qiskit.primitives.containers.sampler_pub import SamplerPub
-from qiskit.primitives.primitive_job import PrimitiveJob
-from qiskit.providers.backend import BackendV1, BackendV2
-from qiskit.result import Result
-
-
-@dataclass
-class Options:
-    """Options for :class:`~.BackendSamplerV2`"""
-
-    default_shots: int = 1024
-    """The default shots to use if none are specified in :meth:`~.run`.
-    Default: 1024.
-    """
-
-    seed_simulator: int | None = None
-    """The seed to use in the simulator. If None, a random seed will be used.
-    Default: None.
-    """
-
-
-@dataclass
-class _MeasureInfo:
-    creg_name: str
-    num_bits: int
-    num_bytes: int
-    start: int
-
-
-class BackendSamplerV2(BaseSamplerV2):
-    """Evaluates bitstrings for provided quantum circuits
-
-    The :class:`~.BackendSamplerV2` class is a generic implementation of the
-    :class:`~.BaseSamplerV2` interface that is used to wrap a :class:`~.BackendV2`
-    (or :class:`~.BackendV1`) object in the class :class:`~.BaseSamplerV2` API. It
-    facilitates using backends that do not provide a native
-    :class:`~.BaseSamplerV2` implementation in places that work with
-    :class:`~.BaseSamplerV2`. However,
-    if you're using a provider that has a native implementation of
-    :class:`~.BaseSamplerV2`, it is a better choice to leverage that native
-    implementation as it will likely include additional optimizations and be
-    a more efficient implementation. The generic nature of this class
-    precludes doing any provider- or backend-specific optimizations.
-
-    This class does not perform any measurement or gate mitigation.
-
-    Each tuple of ``(circuit, <optional> parameter values, <optional> shots)``, called a sampler
-    primitive unified bloc (PUB), produces its own array-valued result. The :meth:`~run` method can
-    be given many pubs at once.
-
-    The options for :class:`~.BackendSamplerV2` consist of the following items.
-
-    * ``default_shots``: The default shots to use if none are specified in :meth:`~run`.
-      Default: 1024.
-
-    * ``seed_simulator``: The seed to use in the simulator. If None, a random seed will be used.
-      Default: None.
-
-    .. note::
-
-        This class requires a backend that supports ``memory`` option.
-
-    """
-
-    def __init__(
-        self,
-        *,
-        backend: BackendV1 | BackendV2,
-        options: dict | None = None,
-    ):
-        """
-        Args:
-            backend: The backend to run the primitive on.
-            options: The options to control the default shots (``default_shots``) and
-                the random seed for the simulator (``seed_simulator``).
-        """
-        self._backend = backend
-        self._options = Options(**options) if options else Options()
-
-    @property
-    def backend(self) -> BackendV1 | BackendV2:
-        """Returns the backend which this sampler object based on."""
-        return self._backend
-
-    @property
-    def options(self) -> Options:
-        """Return the options"""
-        return self._options
-
-    def run(
-        self, pubs: Iterable[SamplerPubLike], *, shots: int | None = None
-    ) -> PrimitiveJob[PrimitiveResult[PubResult]]:
-        if shots is None:
-            shots = self._options.default_shots
-        coerced_pubs = [SamplerPub.coerce(pub, shots) for pub in pubs]
-        self._validate_pubs(coerced_pubs)
-        job = PrimitiveJob(self._run, coerced_pubs)
-        job._submit()
-        return job
-
-    def _validate_pubs(self, pubs: list[SamplerPub]):
-        for i, pub in enumerate(pubs):
-            if len(pub.circuit.cregs) == 0:
-                warnings.warn(
-                    f"The {i}-th pub's circuit has no output classical registers and so the result "
-                    "will be empty. Did you mean to add measurement instructions?",
-                    UserWarning,
-                )
-
-    def _run(self, pubs: Iterable[SamplerPub]) -> PrimitiveResult[PubResult]:
-        results = [self._run_pub(pub) for pub in pubs]
-        return PrimitiveResult(results)
-
-    def _run_pub(self, pub: SamplerPub) -> PubResult:
-        meas_info, max_num_bytes = _analyze_circuit(pub.circuit)
-        bound_circuits = pub.parameter_values.bind_all(pub.circuit)
-        arrays = {
-            item.creg_name: np.zeros(
-                bound_circuits.shape + (pub.shots, item.num_bytes), dtype=np.uint8
-            )
-            for item in meas_info
-        }
-        flatten_circuits = np.ravel(bound_circuits).tolist()
-        result_memory, _ = _run_circuits(
-            flatten_circuits,
-            self._backend,
-            memory=True,
-            shots=pub.shots,
-            seed_simulator=self._options.seed_simulator,
-        )
-        memory_list = _prepare_memory(result_memory, max_num_bytes)
-
-        for samples, index in zip(memory_list, np.ndindex(*bound_circuits.shape)):
-            for item in meas_info:
-                ary = _samples_to_packed_array(samples, item.num_bits, item.start)
-                arrays[item.creg_name][index] = ary
-
-        data_bin_cls = make_data_bin(
-            [(item.creg_name, BitArray) for item in meas_info],
-            shape=bound_circuits.shape,
-        )
-        meas = {
-            item.creg_name: BitArray(arrays[item.creg_name], item.num_bits) for item in meas_info
-        }
-        data_bin = data_bin_cls(**meas)
-        return PubResult(data_bin, metadata={})
-
-
-def _analyze_circuit(circuit: QuantumCircuit) -> tuple[list[_MeasureInfo], int]:
-    meas_info = []
-    max_num_bits = 0
-    for creg in circuit.cregs:
-        name = creg.name
-        num_bits = creg.size
-        start = circuit.find_bit(creg[0]).index
-        meas_info.append(
-            _MeasureInfo(
-                creg_name=name,
-                num_bits=num_bits,
-                num_bytes=_min_num_bytes(num_bits),
-                start=start,
-            )
-        )
-        max_num_bits = max(max_num_bits, start + num_bits)
-    return meas_info, _min_num_bytes(max_num_bits)
-
-
-def _prepare_memory(results: list[Result], num_bytes: int) -> NDArray[np.uint8]:
-    lst = []
-    for res in results:
-        for exp in res.results:
-            if hasattr(exp.data, "memory") and exp.data.memory:
-                data = b"".join(int(i, 16).to_bytes(num_bytes, "big") for i in exp.data.memory)
-                data = np.frombuffer(data, dtype=np.uint8).reshape(-1, num_bytes)
-            else:
-                # no measure in a circuit
-                data = np.zeros((exp.shots, num_bytes), dtype=np.uint8)
-            lst.append(data)
-    ary = np.array(lst, copy=False)
-    return np.unpackbits(ary, axis=-1, bitorder="big")
-
-
-def _samples_to_packed_array(
-    samples: NDArray[np.uint8], num_bits: int, start: int
-) -> NDArray[np.uint8]:
-    # samples of `Backend.run(memory=True)` will be the order of
-    # clbit_last, ..., clbit_1, clbit_0
-    # place samples in the order of clbit_start+num_bits-1, ..., clbit_start+1, clbit_start
-    if start == 0:
-        ary = samples[:, -start - num_bits :]
-    else:
-        ary = samples[:, -start - num_bits : -start]
-    # pad 0 in the left to align the number to be mod 8
-    # since np.packbits(bitorder='big') pads 0 to the right.
-    pad_size = -num_bits % 8
-    ary = np.pad(ary, ((0, 0), (pad_size, 0)), constant_values=0)
-    # pack bits in big endian order
-    ary = np.packbits(ary, axis=-1, bitorder="big")
-    return ary
diff --git a/qiskit/primitives/containers/estimator_pub.py b/qiskit/primitives/containers/estimator_pub.py
index af31327cb..fed278ae1 100644
--- a/qiskit/primitives/containers/estimator_pub.py
+++ b/qiskit/primitives/containers/estimator_pub.py
@@ -132,15 +132,6 @@ class EstimatorPub(ShapedMixin):
                     validate=False,  # Assume Pub is already validated
                 )
             return pub
-
-        if isinstance(pub, QuantumCircuit):
-            raise ValueError(
-                f"An invalid Estimator pub-like was given ({type(pub)}). "
-                "If you want to run a single pub, you need to wrap it with `[]` like "
-                "`estimator.run([(circuit, observables, param_values)])` "
-                "instead of `estimator.run((circuit, observables, param_values))`."
-            )
-
         if len(pub) not in [2, 3, 4]:
             raise ValueError(
                 f"The length of pub must be 2, 3 or 4, but length {len(pub)} is given."
@@ -217,6 +208,8 @@ estimator, if ``precision=None`` the estimator will determine the target precisi
     An Estimator Pub can also be initialized in the following formats which
     will be converted to the full Pub tuple:
 
+    * ``circuit
+    * ``(circuit,)``
     * ``(circuit, observables)``
-    * ``(circuit, observables, parameter_values)``
+    * ``(circuit, observalbes, parameter_values)``
 """
diff --git a/qiskit/primitives/containers/sampler_pub.py b/qiskit/primitives/containers/sampler_pub.py
index d79d8b40e..9828a74c5 100644
--- a/qiskit/primitives/containers/sampler_pub.py
+++ b/qiskit/primitives/containers/sampler_pub.py
@@ -18,11 +18,10 @@ Sampler Pub class
 from __future__ import annotations
 
 from collections.abc import Mapping
-from numbers import Integral
 from typing import Tuple, Union
+from numbers import Integral
 
 from qiskit import QuantumCircuit
-from qiskit.circuit import CircuitInstruction
 
 from .bindings_array import BindingsArray, BindingsArrayLike
 from .shape import ShapedMixin
@@ -114,14 +113,6 @@ class SamplerPub(ShapedMixin):
         if isinstance(pub, QuantumCircuit):
             return cls(circuit=pub, shots=shots, validate=True)
 
-        if isinstance(pub, CircuitInstruction):
-            raise ValueError(
-                f"An invalid Sampler pub-like was given ({type(pub)}). "
-                "If you want to run a single circuit, "
-                "you need to wrap it with `[]` like `sampler.run([circuit])` "
-                "instead of `sampler.run(circuit)`."
-            )
-
         if len(pub) not in [1, 2, 3]:
             raise ValueError(
                 f"The length of pub must be 1, 2 or 3, but length {len(pub)} is given."
@@ -156,17 +147,10 @@ class SamplerPub(ShapedMixin):
         # Cross validate circuits and parameter values
         num_parameters = self.parameter_values.num_parameters
         if num_parameters != self.circuit.num_parameters:
-            message = (
+            raise ValueError(
                 f"The number of values ({num_parameters}) does not match "
                 f"the number of parameters ({self.circuit.num_parameters}) for the circuit."
             )
-            if num_parameters == 0:
-                message += (
-                    " Note that if you want to run a single pub, you need to wrap it with `[]` like "
-                    "`sampler.run([(circuit, param_values)])` instead of "
-                    "`sampler.run((circuit, param_values))`."
-                )
-            raise ValueError(message)
 
 
 SamplerPubLike = Union[
@@ -187,7 +171,7 @@ if ``shots=None`` the number of run shots is determined by the sampler.
     A Sampler Pub can also be initialized in the following formats which
     will be converted to the full Pub tuple:
 
-    * ``circuit``
+    * ``circuit
     * ``(circuit,)``
     * ``(circuit, parameter_values)``
 """
diff --git a/qiskit/providers/backend_compat.py b/qiskit/providers/backend_compat.py
index de57f3f09..e567c330a 100644
--- a/qiskit/providers/backend_compat.py
+++ b/qiskit/providers/backend_compat.py
@@ -1,6 +1,6 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2020.
+# (C) Copyright IBM 2020, 2024.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
@@ -57,7 +57,7 @@ def convert_to_target(
         A ``Target`` instance.
     """
 
-    # importing pacakges where they are needed, to avoid cyclic-import.
+    # importing packages where they are needed, to avoid cyclic-import.
     # pylint: disable=cyclic-import
     from qiskit.transpiler.target import (
         Target,
@@ -82,7 +82,7 @@ def convert_to_target(
         "switch_case": SwitchCaseOp,
     }
 
-    in_data = {"num_qubits": configuration.n_qubits}
+    in_data = {"num_qubits": configuration.num_qubits}
 
     # Parse global configuration properties
     if hasattr(configuration, "dt"):
@@ -97,7 +97,6 @@ def convert_to_target(
     all_instructions = set.union(
         basis_gates, set(required), supported_instructions.intersection(CONTROL_FLOW_OP_NAMES)
     )
-
     inst_name_map = {}  # type: Dict[str, Instruction]
 
     faulty_ops = set()
@@ -244,10 +243,8 @@ def convert_to_target(
 
         for name in inst_sched_map.instructions:
             for qubits in inst_sched_map.qubits_with_instruction(name):
-
                 if not isinstance(qubits, tuple):
                     qubits = (qubits,)
-
                 if (
                     name not in all_instructions
                     or name not in prop_name_map
@@ -267,17 +264,18 @@ def convert_to_target(
                     continue
 
                 entry = inst_sched_map._get_calibration_entry(name, qubits)
-
                 try:
                     prop_name_map[name][qubits].calibration = entry
                 except AttributeError:
+                    # if instruction properties are "None", add entry
+                    prop_name_map[name].update({qubits: InstructionProperties(None, None, entry)})
                     logger.info(
                         "The PulseDefaults payload received contains an instruction %s on "
-                        "qubits %s which is not present in the configuration or properties payload.",
+                        "qubits %s which is not present in the configuration or properties payload."
+                        "A new properties entry will be added to include the new calibration data.",
                         name,
                         qubits,
                     )
-
     # Add parsed properties to target
     target = Target(**in_data)
     for inst_name in all_instructions:
@@ -384,7 +382,7 @@ class BackendV2Converter(BackendV2):
         super().__init__(
             provider=backend.provider,
             name=backend.name(),
-            description=self._config.description,
+            description=getattr(self._config, "description", None),
             online_date=getattr(self._config, "online_date", None),
             backend_version=self._config.backend_version,
         )
diff --git a/qiskit/providers/fake_provider/fake_1q.py b/qiskit/providers/fake_provider/fake_1q.py
index 075894761..09959620b 100644
--- a/qiskit/providers/fake_provider/fake_1q.py
+++ b/qiskit/providers/fake_provider/fake_1q.py
@@ -32,7 +32,7 @@ class Fake1Q(FakeBackend):
         configuration = BackendProperties(
             backend_name="fake_1q",
             backend_version="0.0.0",
-            n_qubits=1,
+            num_qubits=1,
             basis_gates=["u1", "u2", "u3", "cx"],
             simulator=False,
             local=True,
diff --git a/qiskit/pulse/builder.py b/qiskit/pulse/builder.py
index b7bdbe85c..6d57c2e3c 100644
--- a/qiskit/pulse/builder.py
+++ b/qiskit/pulse/builder.py
@@ -531,10 +531,7 @@ class _PulseBuilder:
             self._context_stack.append(root_block)
 
         # Set default alignment context
-        if isinstance(default_alignment, AlignmentKind):  # AlignmentKind instance
-            alignment = default_alignment
-        else:  # str identifier
-            alignment = _PulseBuilder.__alignment_kinds__.get(default_alignment, default_alignment)
+        alignment = _PulseBuilder.__alignment_kinds__.get(default_alignment, default_alignment)
         if not isinstance(alignment, AlignmentKind):
             raise exceptions.PulseError(
                 f"Given `default_alignment` {repr(default_alignment)} is "
diff --git a/qiskit/pulse/utils.py b/qiskit/pulse/utils.py
index fddc9469a..3ccd36201 100644
--- a/qiskit/pulse/utils.py
+++ b/qiskit/pulse/utils.py
@@ -52,29 +52,17 @@ def format_parameter_value(
     Returns:
         Value casted to non-parameter data type, when possible.
     """
-    if isinstance(operand, ParameterExpression):
-        try:
-            operand = operand.numeric()
-        except TypeError:
-            # Unassigned expression
-            return operand
-
-    # Return integer before calling the numpy round function.
-    # The input value is multiplied by 10**decimals, rounds to an integer
-    # and divided by 10**decimals. For a large enough integer,
-    # this operation may introduce a rounding error in the float operations
-    # and accidentally returns a float number.
-    if isinstance(operand, int):
-        return operand
-
-    # Remove truncation error and convert the result into Python builtin type.
-    # Value could originally contain a rounding error, e.g. 1.00000000001
-    # which may occur during the parameter expression evaluation.
-    evaluated = np.round(operand, decimals=decimal).item()
-
-    if isinstance(evaluated, complex):
-        if np.isclose(evaluated.imag, 0.0):
-            evaluated = evaluated.real
+    try:
+        # value is assigned.
+        # note that ParameterExpression directly supports __complex__ via sympy or symengine
+        evaluated = complex(operand)
+        # remove truncation error
+        evaluated = np.round(evaluated, decimals=decimal)
+        # typecast into most likely data type
+        if np.isreal(evaluated):
+            evaluated = float(evaluated.real)
+            if evaluated.is_integer():
+                evaluated = int(evaluated)
         else:
             warnings.warn(
                 "Assignment of complex values to ParameterExpression in Qiskit Pulse objects is "
@@ -88,11 +76,13 @@ def format_parameter_value(
                 "converted in a similar fashion to avoid the use of complex parameters.",
                 PendingDeprecationWarning,
             )
-            return evaluated
-    # Type cast integer-like float into Python builtin integer, after rounding.
-    if evaluated.is_integer():
-        return int(evaluated)
-    return evaluated
+
+        return evaluated
+    except TypeError:
+        # value is not assigned
+        pass
+
+    return operand
 
 
 def instruction_duration_validation(duration: int):
diff --git a/qiskit/synthesis/two_qubit/two_qubit_decompose.py b/qiskit/synthesis/two_qubit/two_qubit_decompose.py
index 9efed2076..9985d7cf5 100644
--- a/qiskit/synthesis/two_qubit/two_qubit_decompose.py
+++ b/qiskit/synthesis/two_qubit/two_qubit_decompose.py
@@ -29,21 +29,21 @@ import math
 import io
 import base64
 import warnings
-from typing import Optional, Type
+from typing import ClassVar, Optional, Type
 
 import logging
 
 import numpy as np
 
 from qiskit.circuit import QuantumRegister, QuantumCircuit, Gate
-from qiskit.circuit.library.standard_gates import CXGate, RXGate
+from qiskit.circuit.library.standard_gates import CXGate, RXGate, RYGate, RZGate
 from qiskit.exceptions import QiskitError
 from qiskit.quantum_info.operators import Operator
+from qiskit.synthesis.two_qubit.weyl import transform_to_magic_basis
 from qiskit.synthesis.one_qubit.one_qubit_decompose import (
     OneQubitEulerDecomposer,
     DEFAULT_ATOL,
 )
-from qiskit.utils.deprecation import deprecate_func
 from qiskit._accelerate import two_qubit_decompose
 
 logger = logging.getLogger(__name__)
@@ -118,9 +118,13 @@ class TwoQubitWeylDecomposition:
 
         \pi /4 \geq a \geq b \geq |c|
 
-    This class avoids some problems of numerical instability near high-symmetry loci within the Weyl
-    chamber. If there is a high-symmetry gate "nearby" (in terms of the requested average gate fidelity),
-    then it return a canonicalized decomposition of that high-symmetry gate.
+    This is an abstract factory class that instantiates itself as specialized subclasses based on
+    the fidelity, such that the approximation error from specialization has an average gate fidelity
+    at least as high as requested. The specialized subclasses have unique canonical representations
+    thus avoiding problems of numerical stability.
+
+    Passing non-None fidelity to specializations is treated as an assertion, raising QiskitError if
+    forcing the specialization is more approximate than asserted.
 
     References:
         1. Cross, A. W., Bishop, L. S., Sheldon, S., Nation, P. D. & Gambetta, J. M.,
@@ -147,30 +151,237 @@ class TwoQubitWeylDecomposition:
     requested_fidelity: Optional[float]  # None means no automatic specialization
     calculated_fidelity: float  # Fidelity after specialization
 
-    _specializations = two_qubit_decompose.Specialization
+    _original_decomposition: "TwoQubitWeylDecomposition"
+    _is_flipped_from_original: bool  # The approx is closest to a Weyl reflection of the original?
+
+    _default_1q_basis: ClassVar[str] = "ZYZ"  # Default one qubit basis (explicit parameterization)
+
+    def __init_subclass__(cls, **kwargs):
+        """Subclasses should be concrete, not factories.
+
+        Make explicitly-instantiated subclass __new__  call base __new__ with fidelity=None"""
+        super().__init_subclass__(**kwargs)
+        cls.__new__ = lambda cls, *a, fidelity=None, **k: TwoQubitWeylDecomposition.__new__(
+            cls, *a, fidelity=None, **k
+        )
+
+    @staticmethod
+    def __new__(cls, unitary_matrix, *, fidelity=(1.0 - 1.0e-9), _unpickling=False):
+        """Perform the Weyl chamber decomposition, and optionally choose a specialized subclass."""
+
+        # The flip into the Weyl Chamber is described in B. Kraus and J. I. Cirac, Phys. Rev. A 63,
+        # 062309 (2001).
+        #
+        # FIXME: There's a cleaner-seeming method based on choosing branch cuts carefully, in Andrew
+        # M. Childs, Henry L. Haselgrove, and Michael A. Nielsen, Phys. Rev. A 68, 052311, but I
+        # wasn't able to get that to work.
+        #
+        # The overall decomposition scheme is taken from Drury and Love, arXiv:0806.4015 [quant-ph].
+
+        if _unpickling:
+            return super().__new__(cls)
+
+        pi = np.pi
+        pi2 = np.pi / 2
+        pi4 = np.pi / 4
+
+        # Make U be in SU(4)
+        U = np.array(unitary_matrix, dtype=complex, copy=True)
+        detU = np.linalg.det(U)
+        U *= detU ** (-0.25)
+        global_phase = cmath.phase(detU) / 4
+
+        Up = transform_to_magic_basis(U, reverse=True)
+        M2 = Up.T.dot(Up)
+
+        # M2 is a symmetric complex matrix. We need to decompose it as M2 = P D P^T where
+        # P ∈ SO(4), D is diagonal with unit-magnitude elements.
+        #
+        # We can't use raw `eig` directly because it isn't guaranteed to give us real or othogonal
+        # eigenvectors.  Instead, since `M2` is complex-symmetric,
+        #   M2 = A + iB
+        # for real-symmetric `A` and `B`, and as
+        #   M2^+ @ M2 = A^2 + B^2 + i [A, B] = 1
+        # we must have `A` and `B` commute, and consequently they are simultaneously diagonalizable.
+        # Mixing them together _should_ account for any degeneracy problems, but it's not
+        # guaranteed, so we repeat it a little bit.  The fixed seed is to make failures
+        # deterministic; the value is not important.
+        state = np.random.default_rng(2020)
+        for _ in range(100):  # FIXME: this randomized algorithm is horrendous
+            M2real = state.normal() * M2.real + state.normal() * M2.imag
+            _, P = np.linalg.eigh(M2real)
+            D = P.T.dot(M2).dot(P).diagonal()
+            if np.allclose(P.dot(np.diag(D)).dot(P.T), M2, rtol=0, atol=1.0e-13):
+                break
+        else:
+            raise QiskitError(
+                "TwoQubitWeylDecomposition: failed to diagonalize M2."
+                " Please report this at https://github.com/Qiskit/qiskit-terra/issues/4159."
+                f" Input: {U.tolist()}"
+            )
+
+        d = -np.angle(D) / 2
+        d[3] = -d[0] - d[1] - d[2]
+        cs = np.mod((d[:3] + d[3]) / 2, 2 * np.pi)
+
+        # Reorder the eigenvalues to get in the Weyl chamber
+        cstemp = np.mod(cs, pi2)
+        np.minimum(cstemp, pi2 - cstemp, cstemp)
+        order = np.argsort(cstemp)[[1, 2, 0]]
+        cs = cs[order]
+        d[:3] = d[order]
+        P[:, :3] = P[:, order]
+
+        # Fix the sign of P to be in SO(4)
+        if np.real(np.linalg.det(P)) < 0:
+            P[:, -1] = -P[:, -1]
+
+        # Find K1, K2 so that U = K1.A.K2, with K being product of single-qubit unitaries
+        K1 = transform_to_magic_basis(Up @ P @ np.diag(np.exp(1j * d)))
+        K2 = transform_to_magic_basis(P.T)
+
+        K1l, K1r, phase_l = decompose_two_qubit_product_gate(K1)
+        K2l, K2r, phase_r = decompose_two_qubit_product_gate(K2)
+        global_phase += phase_l + phase_r
+
+        K1l = K1l.copy()
+
+        # Flip into Weyl chamber
+        if cs[0] > pi2:
+            cs[0] -= 3 * pi2
+            K1l = K1l.dot(_ipy)
+            K1r = K1r.dot(_ipy)
+            global_phase += pi2
+        if cs[1] > pi2:
+            cs[1] -= 3 * pi2
+            K1l = K1l.dot(_ipx)
+            K1r = K1r.dot(_ipx)
+            global_phase += pi2
+        conjs = 0
+        if cs[0] > pi4:
+            cs[0] = pi2 - cs[0]
+            K1l = K1l.dot(_ipy)
+            K2r = _ipy.dot(K2r)
+            conjs += 1
+            global_phase -= pi2
+        if cs[1] > pi4:
+            cs[1] = pi2 - cs[1]
+            K1l = K1l.dot(_ipx)
+            K2r = _ipx.dot(K2r)
+            conjs += 1
+            global_phase += pi2
+            if conjs == 1:
+                global_phase -= pi
+        if cs[2] > pi2:
+            cs[2] -= 3 * pi2
+            K1l = K1l.dot(_ipz)
+            K1r = K1r.dot(_ipz)
+            global_phase += pi2
+            if conjs == 1:
+                global_phase -= pi
+        if conjs == 1:
+            cs[2] = pi2 - cs[2]
+            K1l = K1l.dot(_ipz)
+            K2r = _ipz.dot(K2r)
+            global_phase += pi2
+        if cs[2] > pi4:
+            cs[2] -= pi2
+            K1l = K1l.dot(_ipz)
+            K1r = K1r.dot(_ipz)
+            global_phase -= pi2
+
+        a, b, c = cs[1], cs[0], cs[2]
+
+        # Save the non-specialized decomposition for later comparison
+        od = super().__new__(TwoQubitWeylDecomposition)
+        od.a = a
+        od.b = b
+        od.c = c
+        od.K1l = K1l
+        od.K1r = K1r
+        od.K2l = K2l
+        od.K2r = K2r
+        od.global_phase = global_phase
+        od.requested_fidelity = fidelity
+        od.calculated_fidelity = 1.0
+        od.unitary_matrix = np.array(unitary_matrix, dtype=complex, copy=True)
+        od.unitary_matrix.setflags(write=False)
+        od._original_decomposition = None
+        od._is_flipped_from_original = False
+
+        def is_close(ap, bp, cp):
+            da, db, dc = a - ap, b - bp, c - cp
+            tr = 4 * complex(
+                math.cos(da) * math.cos(db) * math.cos(dc),
+                math.sin(da) * math.sin(db) * math.sin(dc),
+            )
+            fid = trace_to_fid(tr)
+            return fid >= fidelity
+
+        if fidelity is None:  # Don't specialize if None
+            instance = super().__new__(
+                TwoQubitWeylGeneral if cls is TwoQubitWeylDecomposition else cls
+            )
+        elif is_close(0, 0, 0):
+            instance = super().__new__(TwoQubitWeylIdEquiv)
+        elif is_close(pi4, pi4, pi4) or is_close(pi4, pi4, -pi4):
+            instance = super().__new__(TwoQubitWeylSWAPEquiv)
+        elif (lambda x: is_close(x, x, x))(_closest_partial_swap(a, b, c)):
+            instance = super().__new__(TwoQubitWeylPartialSWAPEquiv)
+        elif (lambda x: is_close(x, x, -x))(_closest_partial_swap(a, b, -c)):
+            instance = super().__new__(TwoQubitWeylPartialSWAPFlipEquiv)
+        elif is_close(a, 0, 0):
+            instance = super().__new__(TwoQubitWeylControlledEquiv)
+        elif is_close(pi4, pi4, c):
+            instance = super().__new__(TwoQubitWeylMirrorControlledEquiv)
+        elif is_close((a + b) / 2, (a + b) / 2, c):
+            instance = super().__new__(TwoQubitWeylfSimaabEquiv)
+        elif is_close(a, (b + c) / 2, (b + c) / 2):
+            instance = super().__new__(TwoQubitWeylfSimabbEquiv)
+        elif is_close(a, (b - c) / 2, (c - b) / 2):
+            instance = super().__new__(TwoQubitWeylfSimabmbEquiv)
+        else:
+            instance = super().__new__(TwoQubitWeylGeneral)
+
+        instance._original_decomposition = od
+        return instance
 
     def __init__(
         self,
-        unitary_matrix: np.ndarray,
-        fidelity: float | None = 1.0 - 1.0e-9,
-        *,
-        _specialization: two_qubit_decompose.Specialization | None = None,
+        unitary_matrix: list[list[complex]] | np.ndarray[complex],
+        fidelity: float | None = None,
     ):
-        unitary_matrix = np.asarray(unitary_matrix, dtype=complex)
-        self._inner_decomposition = two_qubit_decompose.TwoQubitWeylDecomposition(
-            unitary_matrix, fidelity=fidelity, _specialization=_specialization
-        )
-        self.a = self._inner_decomposition.a
-        self.b = self._inner_decomposition.b
-        self.c = self._inner_decomposition.c
-        self.global_phase = self._inner_decomposition.global_phase
-        self.K1l = self._inner_decomposition.K1l
-        self.K1r = self._inner_decomposition.K1r
-        self.K2l = self._inner_decomposition.K2l
-        self.K2r = self._inner_decomposition.K2r
-        self.unitary_matrix = unitary_matrix
+        """
+        Args:
+            unitary_matrix: The unitary to decompose.
+            fidelity: The target fidelity of the decomposed operation.
+        """
+        del unitary_matrix  # unused in __init__ (used in new)
+        od = self._original_decomposition
+        self.a, self.b, self.c = od.a, od.b, od.c
+        self.K1l, self.K1r = od.K1l, od.K1r
+        self.K2l, self.K2r = od.K2l, od.K2r
+        self.global_phase = od.global_phase
+        self.unitary_matrix = od.unitary_matrix
         self.requested_fidelity = fidelity
-        self.calculated_fidelity = self._inner_decomposition.calculated_fidelity
+        self._is_flipped_from_original = False
+        self.specialize()
+
+        # Update the phase after specialization:
+        if self._is_flipped_from_original:
+            da, db, dc = (np.pi / 2 - od.a) - self.a, od.b - self.b, -od.c - self.c
+            tr = 4 * complex(
+                math.cos(da) * math.cos(db) * math.cos(dc),
+                math.sin(da) * math.sin(db) * math.sin(dc),
+            )
+        else:
+            da, db, dc = od.a - self.a, od.b - self.b, od.c - self.c
+            tr = 4 * complex(
+                math.cos(da) * math.cos(db) * math.cos(dc),
+                math.sin(da) * math.sin(db) * math.sin(dc),
+            )
+        self.global_phase += cmath.phase(tr)
+        self.calculated_fidelity = trace_to_fid(tr)
         if logger.isEnabledFor(logging.DEBUG):
             actual_fidelity = self.actual_fidelity()
             logger.debug(
@@ -184,34 +395,62 @@ class TwoQubitWeylDecomposition:
                     "Requested fidelity different from actual by %s",
                     self.calculated_fidelity - actual_fidelity,
                 )
+        if self.requested_fidelity and self.calculated_fidelity + 1.0e-13 < self.requested_fidelity:
+            raise QiskitError(
+                f"{self.__class__.__name__}: "
+                f"calculated fidelity: {self.calculated_fidelity} "
+                f"is worse than requested fidelity: {self.requested_fidelity}."
+            )
 
-    @deprecate_func(since="1.1.0", removal_timeline="in the 2.0.0 release")
     def specialize(self):
-        """Make changes to the decomposition to comply with any specializations.
+        """Make changes to the decomposition to comply with any specialization."""
 
-        This method will always raise a ``NotImplementedError`` because
-        there are no specializations to comply with in the current implementation.
-        """
+        # Do update a, b, c, k1l, k1r, k2l, k2r, _is_flipped_from_original to round to the
+        # specialization. Do not update the global phase, since this gets done in generic
+        # __init__()
         raise NotImplementedError
 
     def circuit(
         self, *, euler_basis: str | None = None, simplify: bool = False, atol: float = DEFAULT_ATOL
     ) -> QuantumCircuit:
         """Returns Weyl decomposition in circuit form."""
-        circuit_sequence = self._inner_decomposition.circuit(
-            euler_basis=euler_basis, simplify=simplify, atol=atol
+
+        # simplify, atol arguments are passed to OneQubitEulerDecomposer
+        if euler_basis is None:
+            euler_basis = self._default_1q_basis
+        oneq_decompose = OneQubitEulerDecomposer(euler_basis)
+        c1l, c1r, c2l, c2r = (
+            oneq_decompose(k, simplify=simplify, atol=atol)
+            for k in (self.K1l, self.K1r, self.K2l, self.K2r)
         )
-        circ = QuantumCircuit(2, global_phase=circuit_sequence.global_phase)
-        for name, params, qubits in circuit_sequence:
-            getattr(circ, name)(*params, *qubits)
+        circ = QuantumCircuit(2, global_phase=self.global_phase)
+        circ.compose(c2r, [0], inplace=True)
+        circ.compose(c2l, [1], inplace=True)
+        self._weyl_gate(simplify, circ, atol)
+        circ.compose(c1r, [0], inplace=True)
+        circ.compose(c1l, [1], inplace=True)
         return circ
 
+    def _weyl_gate(self, simplify, circ: QuantumCircuit, atol):
+        """Appends U_d(a, b, c) to the circuit.
+
+        Can be overridden in subclasses for special cases"""
+        if not simplify or abs(self.a) > atol:
+            circ.rxx(-self.a * 2, 0, 1)
+        if not simplify or abs(self.b) > atol:
+            circ.ryy(-self.b * 2, 0, 1)
+        if not simplify or abs(self.c) > atol:
+            circ.rzz(-self.c * 2, 0, 1)
+
     def actual_fidelity(self, **kwargs) -> float:
         """Calculates the actual fidelity of the decomposed circuit to the input unitary."""
         circ = self.circuit(**kwargs)
         trace = np.trace(Operator(circ).data.T.conj() @ self.unitary_matrix)
         return trace_to_fid(trace)
 
+    def __getnewargs_ex__(self):
+        return (self.unitary_matrix,), {"_unpickling": True}
+
     def __repr__(self):
         """Represent with enough precision to allow copy-paste debugging of all corner cases"""
         prefix = f"{type(self).__qualname__}.from_bytes("
@@ -222,15 +461,12 @@ class TwoQubitWeylDecomposition:
         b64ascii[-1] += ","
         pretty = [f"# {x.rstrip()}" for x in str(self).splitlines()]
         indent = "\n" + " " * 4
-        specialization_variant = str(self._inner_decomposition.specialization).split(".")[1]
-        specialization_repr = f"{type(self).__qualname__}._specializations.{specialization_variant}"
         lines = (
             [prefix]
             + pretty
             + b64ascii
             + [
                 f"requested_fidelity={self.requested_fidelity},",
-                f"_specialization={specialization_repr},",
                 f"calculated_fidelity={self.calculated_fidelity},",
                 f"actual_fidelity={self.actual_fidelity()},",
                 f"abc={(self.a, self.b, self.c)})",
@@ -240,12 +476,7 @@ class TwoQubitWeylDecomposition:
 
     @classmethod
     def from_bytes(
-        cls,
-        bytes_in: bytes,
-        *,
-        requested_fidelity: float,
-        _specialization: two_qubit_decompose.Specialization | None = None,
-        **kwargs,
+        cls, bytes_in: bytes, *, requested_fidelity: float, **kwargs
     ) -> "TwoQubitWeylDecomposition":
         """Decode bytes into :class:`.TwoQubitWeylDecomposition`."""
         # Used by __repr__
@@ -253,15 +484,121 @@ class TwoQubitWeylDecomposition:
         b64 = base64.decodebytes(bytes_in)
         with io.BytesIO(b64) as f:
             arr = np.load(f, allow_pickle=False)
-        return cls(arr, fidelity=requested_fidelity, _specialization=_specialization)
+        return cls(arr, fidelity=requested_fidelity)
 
     def __str__(self):
-        specialization = str(self._inner_decomposition.specialization).split(".")[1]
-        pre = f"{self.__class__.__name__} [specialization={specialization}] (\n\t"
+        pre = f"{self.__class__.__name__}(\n\t"
         circ_indent = "\n\t".join(self.circuit(simplify=True).draw("text").lines(-1))
         return f"{pre}{circ_indent}\n)"
 
 
+class TwoQubitWeylIdEquiv(TwoQubitWeylDecomposition):
+    r""":math:`U \sim U_d(0,0,0) \sim Id`
+
+    This gate binds 0 parameters, we make it canonical by setting
+    :math:`K2_l = Id` , :math:`K2_r = Id`.
+    """
+
+    def specialize(self):
+        self.a = self.b = self.c = 0.0
+        self.K1l = self.K1l @ self.K2l
+        self.K1r = self.K1r @ self.K2r
+        self.K2l = _id.copy()
+        self.K2r = _id.copy()
+
+
+class TwoQubitWeylSWAPEquiv(TwoQubitWeylDecomposition):
+    r""":math:`U \sim U_d(\pi/4, \pi/4, \pi/4) \sim U(\pi/4, \pi/4, -\pi/4) \sim \text{SWAP}`
+
+    This gate binds 0 parameters, we make it canonical by setting
+    :math:`K2_l = Id` , :math:`K2_r = Id`.
+    """
+
+    def specialize(self):
+        if self.c > 0:
+            self.K1l = self.K1l @ self.K2r
+            self.K1r = self.K1r @ self.K2l
+        else:
+            self._is_flipped_from_original = True
+            self.K1l = self.K1l @ _ipz @ self.K2r
+            self.K1r = self.K1r @ _ipz @ self.K2l
+            self.global_phase = self.global_phase + np.pi / 2
+        self.a = self.b = self.c = np.pi / 4
+        self.K2l = _id.copy()
+        self.K2r = _id.copy()
+
+    def _weyl_gate(self, simplify, circ: QuantumCircuit, atol):
+        del self, simplify, atol  # unused
+        circ.swap(0, 1)
+        circ.global_phase -= 3 * np.pi / 4
+
+
+def _closest_partial_swap(a, b, c) -> float:
+    r"""A good approximation to the best value x to get the minimum
+    trace distance for :math:`U_d(x, x, x)` from :math:`U_d(a, b, c)`.
+    """
+    m = (a + b + c) / 3
+    am, bm, cm = a - m, b - m, c - m
+    ab, bc, ca = a - b, b - c, c - a
+
+    return m + am * bm * cm * (6 + ab * ab + bc * bc + ca * ca) / 18
+
+
+class TwoQubitWeylPartialSWAPEquiv(TwoQubitWeylDecomposition):
+    r""":math:`U \sim U_d(\alpha\pi/4, \alpha\pi/4, \alpha\pi/4) \sim \text{SWAP}^\alpha`
+    This gate binds 3 parameters, we make it canonical by setting:
+    :math:`K2_l = Id`.
+    """
+
+    def specialize(self):
+        self.a = self.b = self.c = _closest_partial_swap(self.a, self.b, self.c)
+        self.K1l = self.K1l @ self.K2l
+        self.K1r = self.K1r @ self.K2l
+        self.K2r = self.K2l.T.conj() @ self.K2r
+        self.K2l = _id.copy()
+
+
+class TwoQubitWeylPartialSWAPFlipEquiv(TwoQubitWeylDecomposition):
+    r""":math:`U \sim U_d(\alpha\pi/4, \alpha\pi/4, -\alpha\pi/4) \sim \text{SWAP}^\alpha`
+    (a non-equivalent root of SWAP from the TwoQubitWeylPartialSWAPEquiv
+    similar to how :math:`x = (\pm \sqrt(x))^2`)
+    This gate binds 3 parameters, we make it canonical by setting:
+    :math:`K2_l = Id`.
+    """
+
+    def specialize(self):
+        self.a = self.b = _closest_partial_swap(self.a, self.b, -self.c)
+        self.c = -self.a
+        self.K1l = self.K1l @ self.K2l
+        self.K1r = self.K1r @ _ipz @ self.K2l @ _ipz
+        self.K2r = _ipz @ self.K2l.T.conj() @ _ipz @ self.K2r
+        self.K2l = _id.copy()
+
+
+_oneq_xyx = OneQubitEulerDecomposer("XYX")
+_oneq_zyz = OneQubitEulerDecomposer("ZYZ")
+
+
+class TwoQubitWeylControlledEquiv(TwoQubitWeylDecomposition):
+    r""":math:`U \sim U_d(\alpha, 0, 0) \sim \text{Ctrl-U}`
+    This gate binds 4 parameters, we make it canonical by setting:
+        :math:`K2_l = Ry(\theta_l) Rx(\lambda_l)` ,
+        :math:`K2_r = Ry(\theta_r) Rx(\lambda_r)` .
+    """
+
+    _default_1q_basis = "XYX"
+
+    def specialize(self):
+        self.b = self.c = 0
+        k2ltheta, k2lphi, k2llambda, k2lphase = _oneq_xyx.angles_and_phase(self.K2l)
+        k2rtheta, k2rphi, k2rlambda, k2rphase = _oneq_xyx.angles_and_phase(self.K2r)
+        self.global_phase += k2lphase + k2rphase
+        self.K1l = self.K1l @ np.asarray(RXGate(k2lphi))
+        self.K1r = self.K1r @ np.asarray(RXGate(k2rphi))
+        self.K2l = np.asarray(RYGate(k2ltheta)) @ np.asarray(RXGate(k2llambda))
+        self.K2r = np.asarray(RYGate(k2rtheta)) @ np.asarray(RXGate(k2rlambda))
+
+
 class TwoQubitControlledUDecomposer:
     r"""Decompose two-qubit unitary in terms of a desired
     :math:`U \sim U_d(\alpha, 0, 0) \sim \text{Ctrl-U}`
@@ -290,23 +627,18 @@ class TwoQubitControlledUDecomposer:
 
             circ = QuantumCircuit(2)
             circ.rxx(test_angle, 0, 1)
-            decomposer_rxx = TwoQubitWeylDecomposition(
-                Operator(circ).data,
-                fidelity=None,
-                _specialization=two_qubit_decompose.Specialization.ControlledEquiv,
-            )
+            decomposer_rxx = TwoQubitWeylControlledEquiv(Operator(circ).data)
 
             circ = QuantumCircuit(2)
             circ.append(rxx_equivalent_gate(test_angle), qargs=[0, 1])
-            decomposer_equiv = TwoQubitWeylDecomposition(
-                Operator(circ).data,
-                fidelity=None,
-                _specialization=two_qubit_decompose.Specialization.ControlledEquiv,
-            )
+            decomposer_equiv = TwoQubitWeylControlledEquiv(Operator(circ).data)
 
             scale = decomposer_rxx.a / decomposer_equiv.a
 
-            if abs(decomp.a * 2 - test_angle / scale) > atol:
+            if (
+                not isinstance(decomp, TwoQubitWeylControlledEquiv)
+                or abs(decomp.a * 2 - test_angle / scale) > atol
+            ):
                 raise QiskitError(
                     f"{rxx_equivalent_gate.__name__} is not equivalent to an RXXGate."
                 )
@@ -374,7 +706,7 @@ class TwoQubitControlledUDecomposer:
 
         circ = QuantumCircuit(2)
         circ.append(self.rxx_equivalent_gate(self.scale * angle), qargs=[0, 1])
-        decomposer_inv = TwoQubitWeylDecomposition(Operator(circ).data)
+        decomposer_inv = TwoQubitWeylControlledEquiv(Operator(circ).data)
 
         oneq_decompose = OneQubitEulerDecomposer("ZYZ")
 
@@ -431,6 +763,97 @@ class TwoQubitControlledUDecomposer:
         return circ
 
 
+class TwoQubitWeylMirrorControlledEquiv(TwoQubitWeylDecomposition):
+    r""":math:`U \sim U_d(\pi/4, \pi/4, \alpha) \sim \text{SWAP} \cdot \text{Ctrl-U}`
+
+    This gate binds 4 parameters, we make it canonical by setting:
+    :math:`K2_l = Ry(\theta_l)\cdot Rz(\lambda_l)` , :math:`K2_r = Ry(\theta_r)\cdot Rz(\lambda_r)`.
+    """
+
+    def specialize(self):
+        self.a = self.b = np.pi / 4
+        k2ltheta, k2lphi, k2llambda, k2lphase = _oneq_zyz.angles_and_phase(self.K2l)
+        k2rtheta, k2rphi, k2rlambda, k2rphase = _oneq_zyz.angles_and_phase(self.K2r)
+        self.global_phase += k2lphase + k2rphase
+        self.K1r = self.K1r @ np.asarray(RZGate(k2lphi))
+        self.K1l = self.K1l @ np.asarray(RZGate(k2rphi))
+        self.K2l = np.asarray(RYGate(k2ltheta)) @ np.asarray(RZGate(k2llambda))
+        self.K2r = np.asarray(RYGate(k2rtheta)) @ np.asarray(RZGate(k2rlambda))
+
+    def _weyl_gate(self, simplify, circ: QuantumCircuit, atol):
+        circ.swap(0, 1)
+        circ.rzz((np.pi / 4 - self.c) * 2, 0, 1)
+        circ.global_phase += np.pi / 4
+
+
+# These next 3 gates use the definition of fSim from https://arxiv.org/pdf/2001.08343.pdf eq (1)
+class TwoQubitWeylfSimaabEquiv(TwoQubitWeylDecomposition):
+    r""":math:`U \sim U_d(\alpha, \alpha, \beta), \alpha \geq |\beta|`
+
+    This gate binds 5 parameters, we make it canonical by setting:
+    :math:`K2_l = Ry(\theta_l)\cdot Rz(\lambda_l)`.
+    """
+
+    def specialize(self):
+        self.a = self.b = (self.a + self.b) / 2
+        k2ltheta, k2lphi, k2llambda, k2lphase = _oneq_zyz.angles_and_phase(self.K2l)
+        self.global_phase += k2lphase
+        self.K1r = self.K1r @ np.asarray(RZGate(k2lphi))
+        self.K1l = self.K1l @ np.asarray(RZGate(k2lphi))
+        self.K2l = np.asarray(RYGate(k2ltheta)) @ np.asarray(RZGate(k2llambda))
+        self.K2r = np.asarray(RZGate(-k2lphi)) @ self.K2r
+
+
+class TwoQubitWeylfSimabbEquiv(TwoQubitWeylDecomposition):
+    r""":math:`U \sim U_d(\alpha, \beta, -\beta), \alpha \geq \beta \geq 0`
+
+    This gate binds 5 parameters, we make it canonical by setting:
+    :math:`K2_l = Ry(\theta_l)Rx(\lambda_l)`.
+    """
+
+    _default_1q_basis = "XYX"
+
+    def specialize(self):
+        self.b = self.c = (self.b + self.c) / 2
+        k2ltheta, k2lphi, k2llambda, k2lphase = _oneq_xyx.angles_and_phase(self.K2l)
+        self.global_phase += k2lphase
+        self.K1r = self.K1r @ np.asarray(RXGate(k2lphi))
+        self.K1l = self.K1l @ np.asarray(RXGate(k2lphi))
+        self.K2l = np.asarray(RYGate(k2ltheta)) @ np.asarray(RXGate(k2llambda))
+        self.K2r = np.asarray(RXGate(-k2lphi)) @ self.K2r
+
+
+class TwoQubitWeylfSimabmbEquiv(TwoQubitWeylDecomposition):
+    r""":math:`U \sim U_d(\alpha, \beta, -\beta), \alpha \geq \beta \geq 0`
+
+    This gate binds 5 parameters, we make it canonical by setting:
+    :math:`K2_l = Ry(\theta_l)Rx(\lambda_l)`.
+    """
+
+    _default_1q_basis = "XYX"
+
+    def specialize(self):
+        self.b = (self.b - self.c) / 2
+        self.c = -self.b
+        k2ltheta, k2lphi, k2llambda, k2lphase = _oneq_xyx.angles_and_phase(self.K2l)
+        self.global_phase += k2lphase
+        self.K1r = self.K1r @ _ipz @ np.asarray(RXGate(k2lphi)) @ _ipz
+        self.K1l = self.K1l @ np.asarray(RXGate(k2lphi))
+        self.K2l = np.asarray(RYGate(k2ltheta)) @ np.asarray(RXGate(k2llambda))
+        self.K2r = _ipz @ np.asarray(RXGate(-k2lphi)) @ _ipz @ self.K2r
+
+
+class TwoQubitWeylGeneral(TwoQubitWeylDecomposition):
+    """U has no special symmetry.
+
+    This gate binds all 6 possible parameters, so there is no need to make the single-qubit
+    pre-/post-gates canonical.
+    """
+
+    def specialize(self):
+        pass  # Nothing to do
+
+
 def Ud(a, b, c):
     r"""Generates the array :math:`e^{(i a XX + i b YY + i c ZZ)}`"""
     return np.array(
diff --git a/qiskit/transpiler/preset_passmanagers/__init__.py b/qiskit/transpiler/preset_passmanagers/__init__.py
index d8a7fc9b5..b2996d766 100644
--- a/qiskit/transpiler/preset_passmanagers/__init__.py
+++ b/qiskit/transpiler/preset_passmanagers/__init__.py
@@ -115,7 +115,7 @@ def generate_preset_pass_manager(
 
         backend (Backend): An optional backend object which can be used as the
             source of the default values for the ``basis_gates``, ``inst_map``,
-            ``coupling_map``, ``backend_properties``, ``instruction_durations``,
+            ``couplig_map``, ``backend_properties``, ``instruction_durations``,
             ``timing_constraints``, and ``target``. If any of those other arguments
             are specified in addition to ``backend`` they will take precedence
             over the value contained in the backend.
diff --git a/qiskit/visualization/circuit/matplotlib.py b/qiskit/visualization/circuit/matplotlib.py
index 8d83fecb8..a0d4d0ff8 100644
--- a/qiskit/visualization/circuit/matplotlib.py
+++ b/qiskit/visualization/circuit/matplotlib.py
@@ -1544,7 +1544,7 @@ class MatplotlibDrawer:
         while end_x > 0.0:
             x_shift = fold_level * self._fold
             y_shift = fold_level * (glob_data["n_lines"] + 1)
-            end_x = xpos + box_width - x_shift if self._fold > 0 else 0.0
+            end_x = xpos + box_width - x_shift
 
             if isinstance(node.op, IfElseOp):
                 flow_text = "  If"
diff --git a/releasenotes/notes/add-backend-estimator-v2-26cf14a3612bb81a.yaml b/releasenotes/notes/add-backend-estimator-v2-26cf14a3612bb81a.yaml
deleted file mode 100644
index c8ac782f4..000000000
--- a/releasenotes/notes/add-backend-estimator-v2-26cf14a3612bb81a.yaml
+++ /dev/null
@@ -1,28 +0,0 @@
----
-features:
-  - |
-    The implementation :class:`~.BackendEstimatorV2` of :class:`~.BaseEstimatorV2` was added.
-    This estimator supports :class:`~.BackendV1` and :class:`~.BackendV2`.
-
-    .. code-block:: python
-
-      import numpy as np
-      from qiskit import transpile
-      from qiskit.circuit.library import IQP
-      from qiskit.primitives import BackendEstimatorV2
-      from qiskit.providers.fake_provider import Fake7QPulseV1
-      from qiskit.quantum_info import SparsePauliOp, random_hermitian
-
-      backend = Fake7QPulseV1()
-      estimator = BackendEstimatorV2(backend=backend)
-      n_qubits = 5
-      mat = np.real(random_hermitian(n_qubits, seed=1234))
-      circuit = IQP(mat)
-      observable = SparsePauliOp("Z" * n_qubits)
-      isa_circuit = transpile(circuit, backend=backend, optimization_level=1)
-      isa_observable = observable.apply_layout(isa_circuit.layout)
-      job = estimator.run([(isa_circuit, isa_observable)], precision=0.01)
-      result = job.result()
-      print(f"> Expectation value: {result[0].data.evs}")
-      print(f"> Standard error: {result[0].data.stds}")
-      print(f"> Metadata: {result[0].metadata}")
diff --git a/releasenotes/notes/add-backend-sampler-v2-5e40135781eebc7f.yaml b/releasenotes/notes/add-backend-sampler-v2-5e40135781eebc7f.yaml
deleted file mode 100644
index 9cd9002a7..000000000
--- a/releasenotes/notes/add-backend-sampler-v2-5e40135781eebc7f.yaml
+++ /dev/null
@@ -1,28 +0,0 @@
----
-features:
-  - |
-    The implementation :class:`~.BackendSamplerV2` of :class:`~.BaseSamplerV2` was added.
-    This sampler supports :class:`~.BackendV1` and :class:`~.BackendV2` that allow
-    ``memory`` option to compute bitstrings.
-
-    .. code-block:: python
-
-      import numpy as np
-      from qiskit import transpile
-      from qiskit.circuit.library import IQP
-      from qiskit.primitives import BackendSamplerV2
-      from qiskit.providers.fake_provider import Fake7QPulseV1
-      from qiskit.quantum_info import random_hermitian
-
-      backend = Fake7QPulseV1()
-      sampler = BackendSamplerV2(backend=backend)
-      n_qubits = 5
-      mat = np.real(random_hermitian(n_qubits, seed=1234))
-      circuit = IQP(mat)
-      circuit.measure_all()
-      isa_circuit = transpile(circuit, backend=backend, optimization_level=1)
-      job = sampler.run([isa_circuit], shots=100)
-      result = job.result()
-      print(f"> bitstrings: {result[0].data.meas.get_bitstrings()}")
-      print(f"> counts: {result[0].data.meas.get_counts()}")
-      print(f"> Metadata: {result[0].metadata}")
diff --git a/releasenotes/notes/fix-control-flow-fold-minus-one-f2af168a5313385f.yaml b/releasenotes/notes/fix-control-flow-fold-minus-one-f2af168a5313385f.yaml
deleted file mode 100644
index 5f8567da7..000000000
--- a/releasenotes/notes/fix-control-flow-fold-minus-one-f2af168a5313385f.yaml
+++ /dev/null
@@ -1,8 +0,0 @@
----
-fixes:
-  - |
-    Fixed an issue with the :func:`circuit_drawer` or :meth:`QuantumCircuit.draw`
-    when using the ``mpl`` output option where the program would hang if the
-    circuit being drawn had a ControlFlow operation in it and the ``fold`` option
-    was set to -1 (meaning no fold).
-    Fixed `#12012 <https://github.com/Qiskit/qiskit/issues/12012>`__.
diff --git a/releasenotes/notes/fix-pulse-builder-default-alingment-52f81224d90c21e2.yaml b/releasenotes/notes/fix-pulse-builder-default-alingment-52f81224d90c21e2.yaml
deleted file mode 100644
index b8d775e82..000000000
--- a/releasenotes/notes/fix-pulse-builder-default-alingment-52f81224d90c21e2.yaml
+++ /dev/null
@@ -1,6 +0,0 @@
----
-fixes:
-  - |
-    Fixed a bug in the handling of ``default_alignment`` argument of :func:`~qiskit.pulse.build`.
-    Inputs of type :class:`~qiskit.pulse.transforms.AlignmentKind` are now correctly processed as
-    default alignments.
diff --git a/releasenotes/notes/fix-pulse-parameter-formatter-2ee3fb91efb2794c.yaml b/releasenotes/notes/fix-pulse-parameter-formatter-2ee3fb91efb2794c.yaml
deleted file mode 100644
index e4749646e..000000000
--- a/releasenotes/notes/fix-pulse-parameter-formatter-2ee3fb91efb2794c.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-fixes:
-  - |
-    Fixed a bug in :func:`qiskit.pulse.utils.format_parameter_value` function that
-    unintentionally converts large enough integer numbers into float values
-    or causes unexpected rounding.
-    See `qiskit/#11971 <https://github.com/Qiskit/qiskit/issues/11971>`__  for details.
diff --git a/releasenotes/notes/rust-two-qubit-weyl-ec551f3f9c812124.yaml b/releasenotes/notes/rust-two-qubit-weyl-ec551f3f9c812124.yaml
deleted file mode 100644
index 12d5c27d9..000000000
--- a/releasenotes/notes/rust-two-qubit-weyl-ec551f3f9c812124.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-features_synthesis:
-  - |
-    The :class:`.TwoQubitWeylDecomposition` synthesis class has been rewritten
-    in Rust for better performance.
-upgrade_synthesis:
-  - |
-    The :class:`.TwoQubitWeylDecomposition` no longer will self-specialize into
-    a subclass on creation. This was an internal detail of the :class:`.TwoQubitWeylDecomposition`
-    previously, and was not a documented public behavior as all the subclasses behaved
-    the same and were only used for internal dispatch. However, as it was discoverable
-    behavior this release note is to document that this will no longer occur and all
-    instances of :class:`.TwoQubitWeylDecomposition` will be of the same type. There is no
-    change in behavior for public methods of the class.
-
-deprecations_synthesis:
-  - |
-    The :meth:`.TwoQubitWeylDecomposition.specialize` method is now deprecated
-    and will be removed in the Qiskit 2.0.0 release. This method never had
-    a public purpose and was unsafe for an end user to call as it would
-    mutate the calculated decomposition in the object and produce invalid
-    fields in the object. It was only used internally to construct a new
-    :class:`.TwoQubitWeylDecomposition` object. Despite this it was still a
-    documented part of the public API for the class and is now being
-    deprecated without any potential replacement. This release it always will
-    raise a ``NotImplementedError`` when called because the specialization
-    subclassing has been removed as part of the Rust rewrite of the class.
diff --git a/test/python/compiler/test_transpiler.py b/test/python/compiler/test_transpiler.py
index e18f483fb..30b95bc41 100644
--- a/test/python/compiler/test_transpiler.py
+++ b/test/python/compiler/test_transpiler.py
@@ -74,10 +74,11 @@ from qiskit.converters import circuit_to_dag
 from qiskit.dagcircuit import DAGOpNode, DAGOutNode
 from qiskit.exceptions import QiskitError
 from qiskit.providers.backend import BackendV2
-from qiskit.providers.fake_provider import Fake20QV1, GenericBackendV2
+from qiskit.providers.backend_compat import BackendV2Converter
+from qiskit.providers.fake_provider import Fake20QV1, Fake27QPulseV1, GenericBackendV2
 from qiskit.providers.basic_provider import BasicSimulator
 from qiskit.providers.options import Options
-from qiskit.pulse import InstructionScheduleMap
+from qiskit.pulse import InstructionScheduleMap, Schedule, Play, Gaussian, DriveChannel
 from qiskit.quantum_info import Operator, random_unitary
 from qiskit.utils import parallel
 from qiskit.transpiler import CouplingMap, Layout, PassManager, TransformationPass
@@ -85,7 +86,13 @@ from qiskit.transpiler.exceptions import TranspilerError, CircuitTooWideForTarge
 from qiskit.transpiler.passes import BarrierBeforeFinalMeasurements, GateDirection, VF2PostLayout
 from qiskit.transpiler.passmanager_config import PassManagerConfig
 from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager, level_0_pass_manager
-from qiskit.transpiler.target import InstructionProperties, Target
+from qiskit.transpiler.target import (
+    InstructionProperties,
+    Target,
+    TimingConstraints,
+    InstructionDurations,
+)
+
 from test import QiskitTestCase, combine, slow_test  # pylint: disable=wrong-import-order
 
 from ..legacy_cmaps import MELBOURNE_CMAP, RUESCHLIKON_CMAP
@@ -1498,6 +1505,86 @@ class TestTranspile(QiskitTestCase):
         self.assertIn("delay", out[0].count_ops())
         self.assertIn("delay", out[1].count_ops())
 
+    def test_scheduling_timing_constraints(self):
+        """Test that scheduling-related loose transpile constraints
+        work with both BackendV1 and BackendV2."""
+
+        backend_v1 = Fake27QPulseV1()
+        backend_v2 = BackendV2Converter(backend_v1)
+        # the original timing constraints are granularity = min_length = 16
+        timing_constraints = TimingConstraints(granularity=32, min_length=64)
+        error_msgs = {
+            65: "Pulse duration is not multiple of 32",
+            32: "Pulse gate duration is less than 64",
+        }
+
+        for backend, duration in zip([backend_v1, backend_v2], [65, 32]):
+            with self.subTest(backend=backend, duration=duration):
+                qc = QuantumCircuit(2)
+                qc.h(0)
+                qc.cx(0, 1)
+                qc.measure_all()
+                qc.add_calibration(
+                    "h", [0], Schedule(Play(Gaussian(duration, 0.2, 4), DriveChannel(0))), [0, 0]
+                )
+                qc.add_calibration(
+                    "cx",
+                    [0, 1],
+                    Schedule(Play(Gaussian(duration, 0.2, 4), DriveChannel(1))),
+                    [0, 0],
+                )
+                with self.assertRaisesRegex(TranspilerError, error_msgs[duration]):
+                    _ = transpile(
+                        qc,
+                        backend=backend,
+                        timing_constraints=timing_constraints,
+                    )
+
+    def test_scheduling_instruction_constraints(self):
+        """Test that scheduling-related loose transpile constraints
+        work with BackendV1."""
+
+        backend_v1 = Fake27QPulseV1()
+        backend_v2 = BackendV2Converter(backend_v1)
+        qc = QuantumCircuit(2)
+        qc.h(0)
+        qc.delay(500, 1, "dt")
+        qc.cx(0, 1)
+        # update durations
+        durations = InstructionDurations.from_backend(backend_v1)
+        durations.update([("cx", [0, 1], 1000, "dt")])
+
+        for backend in [backend_v1, backend_v2]:
+            with self.subTest(backend=backend):
+                scheduled = transpile(
+                    qc,
+                    backend=backend,
+                    scheduling_method="alap",
+                    instruction_durations=durations,
+                    layout_method="trivial",
+                )
+                self.assertEqual(scheduled.duration, 1500)
+
+    def test_scheduling_dt_constraints(self):
+        """Test that scheduling-related loose transpile constraints
+        work with BackendV1."""
+
+        backend_v1 = Fake27QPulseV1()
+        backend_v2 = BackendV2Converter(backend_v1)
+        qc = QuantumCircuit(1, 1)
+        qc.x(0)
+        qc.measure(0, 0)
+        original_dt = 2.2222222222222221e-10
+        original_duration = 3504
+
+        for backend in [backend_v1, backend_v2]:
+            with self.subTest(backend=backend):
+                # halve dt in sec = double duration in dt
+                scheduled = transpile(
+                    qc, backend=backend, scheduling_method="asap", dt=original_dt / 2
+                )
+                self.assertEqual(scheduled.duration, original_duration * 2)
+
     @data(1, 2, 3)
     def test_no_infinite_loop(self, optimization_level):
         """Verify circuit cost always descends and optimization does not flip flop indefinitely."""
diff --git a/test/python/primitives/test_backend_estimator.py b/test/python/primitives/test_backend_estimator.py
index 9725b865b..6e14d7e4c 100644
--- a/test/python/primitives/test_backend_estimator.py
+++ b/test/python/primitives/test_backend_estimator.py
@@ -56,7 +56,6 @@ class TestBackendEstimator(QiskitTestCase):
 
     def setUp(self):
         super().setUp()
-        self._rng = np.random.default_rng(12)
         self.ansatz = RealAmplitudes(num_qubits=2, reps=2)
         self.observable = SparsePauliOp.from_list(
             [
@@ -102,7 +101,7 @@ class TestBackendEstimator(QiskitTestCase):
         # Note that passing objects has an overhead
         # since the corresponding indices need to be searched.
         # User can append a circuit and observable.
-        # calculate [ <psi2(theta2)|H1|psi2(theta2)> ]
+        # calculate [ <psi2(theta2)|H2|psi2(theta2)> ]
         result2 = estimator.run([psi2], [hamiltonian1], [theta2]).result()
         np.testing.assert_allclose(result2.values, [2.97797666], rtol=0.5, atol=0.2)
 
@@ -223,7 +222,7 @@ class TestBackendEstimator(QiskitTestCase):
         qc = RealAmplitudes(num_qubits=2, reps=2)
         op = SparsePauliOp.from_list([("IZ", 1), ("XI", 2), ("ZY", -1)])
         k = 5
-        params_array = self._rng.random((k, qc.num_parameters))
+        params_array = np.random.rand(k, qc.num_parameters)
         params_list = params_array.tolist()
         params_list_array = list(params_array)
         estimator = BackendEstimator(backend=backend)
@@ -289,7 +288,7 @@ class TestBackendEstimator(QiskitTestCase):
         qc = RealAmplitudes(num_qubits=2, reps=2)
         op = SparsePauliOp.from_list([("IZ", 1), ("XI", 2), ("ZY", -1)])
         k = 5
-        params_array = self._rng.random((k, qc.num_parameters))
+        params_array = np.random.rand(k, qc.num_parameters)
         params_list = params_array.tolist()
         estimator = BackendEstimator(backend=backend)
         with patch.object(backend, "run") as run_mock:
@@ -305,7 +304,7 @@ class TestBackendEstimator(QiskitTestCase):
         qc = RealAmplitudes(num_qubits=2, reps=2)
         op = SparsePauliOp.from_list([("IZ", 1), ("XI", 2), ("ZY", -1)])
         k = 5
-        params_array = self._rng.random((k, qc.num_parameters))
+        params_array = np.random.rand(k, qc.num_parameters)
         params_list = params_array.tolist()
         estimator = BackendEstimator(backend=backend)
         estimator.set_options(seed_simulator=123)
@@ -322,7 +321,7 @@ class TestBackendEstimator(QiskitTestCase):
         qc = RealAmplitudes(num_qubits=2, reps=2)
         op = SparsePauliOp.from_list([("IZ", 1), ("XI", 2), ("ZY", -1)])
         k = 5
-        params_array = self._rng.random((k, qc.num_parameters))
+        params_array = np.random.rand(k, qc.num_parameters)
         params_list = params_array.tolist()
         params_list_array = list(params_array)
         estimator = BackendEstimator(backend=backend)
diff --git a/test/python/primitives/test_backend_estimator_v2.py b/test/python/primitives/test_backend_estimator_v2.py
deleted file mode 100644
index 570b117af..000000000
--- a/test/python/primitives/test_backend_estimator_v2.py
+++ /dev/null
@@ -1,412 +0,0 @@
-# This code is part of Qiskit.
-#
-# (C) Copyright IBM 2024.
-#
-# This code is licensed under the Apache License, Version 2.0. You may
-# obtain a copy of this license in the LICENSE.txt file in the root directory
-# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
-#
-# Any modifications or derivative works of this code must retain this
-# copyright notice, and modified files need to carry a notice indicating
-# that they have been altered from the originals.
-
-"""Tests for Backend Estimator V2."""
-
-from __future__ import annotations
-
-import unittest
-from test import QiskitTestCase, combine
-
-import numpy as np
-from ddt import ddt
-
-from qiskit.circuit import Parameter, QuantumCircuit
-from qiskit.circuit.library import RealAmplitudes
-from qiskit.primitives import BackendEstimatorV2, StatevectorEstimator
-from qiskit.primitives.containers.bindings_array import BindingsArray
-from qiskit.primitives.containers.estimator_pub import EstimatorPub
-from qiskit.primitives.containers.observables_array import ObservablesArray
-from qiskit.providers.backend_compat import BackendV2Converter
-from qiskit.providers.basic_provider import BasicSimulator
-from qiskit.providers.fake_provider import Fake7QPulseV1
-from qiskit.quantum_info import SparsePauliOp
-from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
-from qiskit.utils import optionals
-
-BACKENDS = [BasicSimulator(), Fake7QPulseV1(), BackendV2Converter(Fake7QPulseV1())]
-
-
-@ddt
-class TestBackendEstimatorV2(QiskitTestCase):
-    """Test Estimator"""
-
-    def setUp(self):
-        super().setUp()
-        self._precision = 5e-3
-        self._rtol = 3e-1
-        self._seed = 12
-        self._rng = np.random.default_rng(self._seed)
-        self._options = {"default_precision": self._precision, "seed_simulator": self._seed}
-        self.ansatz = RealAmplitudes(num_qubits=2, reps=2)
-        self.observable = SparsePauliOp.from_list(
-            [
-                ("II", -1.052373245772859),
-                ("IZ", 0.39793742484318045),
-                ("ZI", -0.39793742484318045),
-                ("ZZ", -0.01128010425623538),
-                ("XX", 0.18093119978423156),
-            ]
-        )
-        self.expvals = -1.0284380963435145, -1.284366511861733
-
-        self.psi = (RealAmplitudes(num_qubits=2, reps=2), RealAmplitudes(num_qubits=2, reps=3))
-        self.params = tuple(psi.parameters for psi in self.psi)
-        self.hamiltonian = (
-            SparsePauliOp.from_list([("II", 1), ("IZ", 2), ("XI", 3)]),
-            SparsePauliOp.from_list([("IZ", 1)]),
-            SparsePauliOp.from_list([("ZI", 1), ("ZZ", 1)]),
-        )
-        self.theta = (
-            [0, 1, 1, 2, 3, 5],
-            [0, 1, 1, 2, 3, 5, 8, 13],
-            [1, 2, 3, 4, 5, 6],
-        )
-
-    @combine(backend=BACKENDS, abelian_grouping=[True, False])
-    def test_estimator_run(self, backend, abelian_grouping):
-        """Test Estimator.run()"""
-        psi1, psi2 = self.psi
-        hamiltonian1, hamiltonian2, hamiltonian3 = self.hamiltonian
-        theta1, theta2, theta3 = self.theta
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        psi1, psi2 = pm.run([psi1, psi2])
-        estimator = BackendEstimatorV2(backend=backend, options=self._options)
-        estimator.options.abelian_grouping = abelian_grouping
-        # Specify the circuit and observable by indices.
-        # calculate [ <psi1(theta1)|H1|psi1(theta1)> ]
-        ham1 = hamiltonian1.apply_layout(psi1.layout)
-        job = estimator.run([(psi1, ham1, [theta1])])
-        result = job.result()
-        np.testing.assert_allclose(result[0].data.evs, [1.5555572817900956], rtol=self._rtol)
-
-        # Objects can be passed instead of indices.
-        # Note that passing objects has an overhead
-        # since the corresponding indices need to be searched.
-        # User can append a circuit and observable.
-        # calculate [ <psi2(theta2)|H1|psi2(theta2)> ]
-        ham1 = hamiltonian1.apply_layout(psi2.layout)
-        result2 = estimator.run([(psi2, ham1, theta2)]).result()
-        np.testing.assert_allclose(result2[0].data.evs, [2.97797666], rtol=self._rtol)
-
-        # calculate [ <psi1(theta1)|H2|psi1(theta1)>, <psi1(theta1)|H3|psi1(theta1)> ]
-        ham2 = hamiltonian2.apply_layout(psi1.layout)
-        ham3 = hamiltonian3.apply_layout(psi1.layout)
-        result3 = estimator.run([(psi1, [ham2, ham3], theta1)]).result()
-        np.testing.assert_allclose(result3[0].data.evs, [-0.551653, 0.07535239], rtol=self._rtol)
-
-        # calculate [ [<psi1(theta1)|H1|psi1(theta1)>,
-        #              <psi1(theta3)|H3|psi1(theta3)>],
-        #             [<psi2(theta2)|H2|psi2(theta2)>] ]
-        ham1 = hamiltonian1.apply_layout(psi1.layout)
-        ham3 = hamiltonian3.apply_layout(psi1.layout)
-        ham2 = hamiltonian2.apply_layout(psi2.layout)
-        result4 = estimator.run(
-            [
-                (psi1, [ham1, ham3], [theta1, theta3]),
-                (psi2, ham2, theta2),
-            ]
-        ).result()
-        np.testing.assert_allclose(result4[0].data.evs, [1.55555728, -1.08766318], rtol=self._rtol)
-        np.testing.assert_allclose(result4[1].data.evs, [0.17849238], rtol=self._rtol)
-
-    @combine(backend=BACKENDS, abelian_grouping=[True, False])
-    def test_estimator_with_pub(self, backend, abelian_grouping):
-        """Test estimator with explicit EstimatorPubs."""
-        psi1, psi2 = self.psi
-        hamiltonian1, hamiltonian2, hamiltonian3 = self.hamiltonian
-        theta1, theta2, theta3 = self.theta
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        psi1, psi2 = pm.run([psi1, psi2])
-
-        ham1 = hamiltonian1.apply_layout(psi1.layout)
-        ham3 = hamiltonian3.apply_layout(psi1.layout)
-        obs1 = ObservablesArray.coerce([ham1, ham3])
-        bind1 = BindingsArray.coerce({tuple(psi1.parameters): [theta1, theta3]})
-        pub1 = EstimatorPub(psi1, obs1, bind1)
-
-        ham2 = hamiltonian2.apply_layout(psi2.layout)
-        obs2 = ObservablesArray.coerce(ham2)
-        bind2 = BindingsArray.coerce({tuple(psi2.parameters): theta2})
-        pub2 = EstimatorPub(psi2, obs2, bind2)
-
-        estimator = BackendEstimatorV2(backend=backend, options=self._options)
-        estimator.options.abelian_grouping = abelian_grouping
-        result4 = estimator.run([pub1, pub2]).result()
-        np.testing.assert_allclose(result4[0].data.evs, [1.55555728, -1.08766318], rtol=self._rtol)
-        np.testing.assert_allclose(result4[1].data.evs, [0.17849238], rtol=self._rtol)
-
-    @combine(backend=BACKENDS, abelian_grouping=[True, False])
-    def test_estimator_run_no_params(self, backend, abelian_grouping):
-        """test for estimator without parameters"""
-        circuit = self.ansatz.assign_parameters([0, 1, 1, 2, 3, 5])
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        circuit = pm.run(circuit)
-        est = BackendEstimatorV2(backend=backend, options=self._options)
-        est.options.abelian_grouping = abelian_grouping
-        observable = self.observable.apply_layout(circuit.layout)
-        result = est.run([(circuit, observable)]).result()
-        np.testing.assert_allclose(result[0].data.evs, [-1.284366511861733], rtol=self._rtol)
-
-    @combine(backend=BACKENDS, abelian_grouping=[True, False])
-    def test_run_single_circuit_observable(self, backend, abelian_grouping):
-        """Test for single circuit and single observable case."""
-        est = BackendEstimatorV2(backend=backend, options=self._options)
-        est.options.abelian_grouping = abelian_grouping
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-
-        with self.subTest("No parameter"):
-            qc = QuantumCircuit(1)
-            qc.x(0)
-            qc = pm.run(qc)
-            op = SparsePauliOp("Z")
-            op = op.apply_layout(qc.layout)
-            param_vals = [None, [], [[]], np.array([]), np.array([[]]), [np.array([])]]
-            target = [-1]
-            for val in param_vals:
-                self.subTest(f"{val}")
-                result = est.run([(qc, op, val)]).result()
-                np.testing.assert_allclose(result[0].data.evs, target, rtol=self._rtol)
-                self.assertEqual(result[0].metadata["target_precision"], self._precision)
-
-        with self.subTest("One parameter"):
-            param = Parameter("x")
-            qc = QuantumCircuit(1)
-            qc.ry(param, 0)
-            qc = pm.run(qc)
-            op = SparsePauliOp("Z")
-            op = op.apply_layout(qc.layout)
-            param_vals = [
-                [np.pi],
-                np.array([np.pi]),
-            ]
-            target = [-1]
-            for val in param_vals:
-                self.subTest(f"{val}")
-                result = est.run([(qc, op, val)]).result()
-                np.testing.assert_allclose(result[0].data.evs, target, rtol=self._rtol)
-                self.assertEqual(result[0].metadata["target_precision"], self._precision)
-
-        with self.subTest("More than one parameter"):
-            qc = self.psi[0]
-            qc = pm.run(qc)
-            op = self.hamiltonian[0]
-            op = op.apply_layout(qc.layout)
-            param_vals = [
-                self.theta[0],
-                [self.theta[0]],
-                np.array(self.theta[0]),
-                np.array([self.theta[0]]),
-                [np.array(self.theta[0])],
-            ]
-            target = [1.5555572817900956]
-            for val in param_vals:
-                self.subTest(f"{val}")
-                result = est.run([(qc, op, val)]).result()
-                np.testing.assert_allclose(result[0].data.evs, target, rtol=self._rtol)
-                self.assertEqual(result[0].metadata["target_precision"], self._precision)
-
-    @combine(backend=BACKENDS, abelian_grouping=[True, False])
-    def test_run_1qubit(self, backend, abelian_grouping):
-        """Test for 1-qubit cases"""
-        qc = QuantumCircuit(1)
-        qc2 = QuantumCircuit(1)
-        qc2.x(0)
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        qc, qc2 = pm.run([qc, qc2])
-
-        op = SparsePauliOp.from_list([("I", 1)])
-        op2 = SparsePauliOp.from_list([("Z", 1)])
-
-        est = BackendEstimatorV2(backend=backend, options=self._options)
-        est.options.abelian_grouping = abelian_grouping
-        op_1 = op.apply_layout(qc.layout)
-        result = est.run([(qc, op_1)]).result()
-        np.testing.assert_allclose(result[0].data.evs, [1], rtol=self._rtol)
-
-        op_2 = op2.apply_layout(qc.layout)
-        result = est.run([(qc, op_2)]).result()
-        np.testing.assert_allclose(result[0].data.evs, [1], rtol=self._rtol)
-
-        op_3 = op.apply_layout(qc2.layout)
-        result = est.run([(qc2, op_3)]).result()
-        np.testing.assert_allclose(result[0].data.evs, [1], rtol=self._rtol)
-
-        op_4 = op2.apply_layout(qc2.layout)
-        result = est.run([(qc2, op_4)]).result()
-        np.testing.assert_allclose(result[0].data.evs, [-1], rtol=self._rtol)
-
-    @combine(backend=BACKENDS, abelian_grouping=[True, False])
-    def test_run_2qubits(self, backend, abelian_grouping):
-        """Test for 2-qubit cases (to check endian)"""
-        qc = QuantumCircuit(2)
-        qc2 = QuantumCircuit(2)
-        qc2.x(0)
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        qc, qc2 = pm.run([qc, qc2])
-
-        op = SparsePauliOp.from_list([("II", 1)])
-        op2 = SparsePauliOp.from_list([("ZI", 1)])
-        op3 = SparsePauliOp.from_list([("IZ", 1)])
-
-        est = BackendEstimatorV2(backend=backend, options=self._options)
-        est.options.abelian_grouping = abelian_grouping
-        op_1 = op.apply_layout(qc.layout)
-        result = est.run([(qc, op_1)]).result()
-        np.testing.assert_allclose(result[0].data.evs, [1], rtol=self._rtol)
-
-        op_2 = op.apply_layout(qc2.layout)
-        result = est.run([(qc2, op_2)]).result()
-        np.testing.assert_allclose(result[0].data.evs, [1], rtol=self._rtol)
-
-        op_3 = op2.apply_layout(qc.layout)
-        result = est.run([(qc, op_3)]).result()
-        np.testing.assert_allclose(result[0].data.evs, [1], rtol=self._rtol)
-
-        op_4 = op2.apply_layout(qc2.layout)
-        result = est.run([(qc2, op_4)]).result()
-        np.testing.assert_allclose(result[0].data.evs, [1], rtol=self._rtol)
-
-        op_5 = op3.apply_layout(qc.layout)
-        result = est.run([(qc, op_5)]).result()
-        np.testing.assert_allclose(result[0].data.evs, [1], rtol=self._rtol)
-
-        op_6 = op3.apply_layout(qc2.layout)
-        result = est.run([(qc2, op_6)]).result()
-        np.testing.assert_allclose(result[0].data.evs, [-1], rtol=self._rtol)
-
-    @combine(backend=BACKENDS, abelian_grouping=[True, False])
-    def test_run_errors(self, backend, abelian_grouping):
-        """Test for errors"""
-        qc = QuantumCircuit(1)
-        qc2 = QuantumCircuit(2)
-
-        op = SparsePauliOp.from_list([("I", 1)])
-        op2 = SparsePauliOp.from_list([("II", 1)])
-
-        est = BackendEstimatorV2(backend=backend, options=self._options)
-        est.options.abelian_grouping = abelian_grouping
-        with self.assertRaises(ValueError):
-            est.run([(qc, op2)]).result()
-        with self.assertRaises(ValueError):
-            est.run([(qc, op, [[1e4]])]).result()
-        with self.assertRaises(ValueError):
-            est.run([(qc2, op2, [[1, 2]])]).result()
-        with self.assertRaises(ValueError):
-            est.run([(qc, [op, op2], [[1]])]).result()
-        with self.assertRaises(ValueError):
-            est.run([(qc, op)], precision=-1).result()
-        with self.assertRaises(ValueError):
-            est.run([(qc, 1j * op)], precision=0.1).result()
-        # precision == 0
-        with self.assertRaises(ValueError):
-            est.run([(qc, op, None, 0)]).result()
-        with self.assertRaises(ValueError):
-            est.run([(qc, op)], precision=0).result()
-        # precision < 0
-        with self.assertRaises(ValueError):
-            est.run([(qc, op, None, -1)]).result()
-        with self.assertRaises(ValueError):
-            est.run([(qc, op)], precision=-1).result()
-        with self.subTest("missing []"):
-            with self.assertRaisesRegex(ValueError, "An invalid Estimator pub-like was given"):
-                _ = est.run((qc, op)).result()
-
-    @combine(backend=BACKENDS, abelian_grouping=[True, False])
-    def test_run_numpy_params(self, backend, abelian_grouping):
-        """Test for numpy array as parameter values"""
-        qc = RealAmplitudes(num_qubits=2, reps=2)
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        qc = pm.run(qc)
-        op = SparsePauliOp.from_list([("IZ", 1), ("XI", 2), ("ZY", -1)])
-        op = op.apply_layout(qc.layout)
-        k = 5
-        params_array = self._rng.random((k, qc.num_parameters))
-        params_list = params_array.tolist()
-        params_list_array = list(params_array)
-        statevector_estimator = StatevectorEstimator(seed=123)
-        target = statevector_estimator.run([(qc, op, params_list)]).result()
-
-        backend_estimator = BackendEstimatorV2(backend=backend, options=self._options)
-        backend_estimator.options.abelian_grouping = abelian_grouping
-
-        with self.subTest("ndarrary"):
-            result = backend_estimator.run([(qc, op, params_array)]).result()
-            self.assertEqual(result[0].data.evs.shape, (k,))
-            np.testing.assert_allclose(result[0].data.evs, target[0].data.evs, rtol=self._rtol)
-
-        with self.subTest("list of ndarray"):
-            result = backend_estimator.run([(qc, op, params_list_array)]).result()
-            self.assertEqual(result[0].data.evs.shape, (k,))
-            np.testing.assert_allclose(result[0].data.evs, target[0].data.evs, rtol=self._rtol)
-
-    @combine(backend=BACKENDS, abelian_grouping=[True, False])
-    def test_precision(self, backend, abelian_grouping):
-        """Test for precision"""
-        estimator = BackendEstimatorV2(backend=backend, options=self._options)
-        estimator.options.abelian_grouping = abelian_grouping
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        psi1 = pm.run(self.psi[0])
-        hamiltonian1 = self.hamiltonian[0].apply_layout(psi1.layout)
-        theta1 = self.theta[0]
-        job = estimator.run([(psi1, hamiltonian1, [theta1])])
-        result = job.result()
-        np.testing.assert_allclose(result[0].data.evs, [1.901141473854881], rtol=self._rtol)
-        # The result of the second run is the same
-        job = estimator.run([(psi1, hamiltonian1, [theta1]), (psi1, hamiltonian1, [theta1])])
-        result = job.result()
-        np.testing.assert_allclose(result[0].data.evs, [1.901141473854881], rtol=self._rtol)
-        np.testing.assert_allclose(result[1].data.evs, [1.901141473854881], rtol=self._rtol)
-        # apply smaller precision value
-        job = estimator.run([(psi1, hamiltonian1, [theta1])], precision=self._precision * 0.5)
-        result = job.result()
-        np.testing.assert_allclose(result[0].data.evs, [1.5555572817900956], rtol=self._rtol)
-
-    @unittest.skipUnless(optionals.HAS_AER, "qiskit-aer is required to run this test")
-    @combine(abelian_grouping=[True, False])
-    def test_aer(self, abelian_grouping):
-        """Test for Aer simulator"""
-        from qiskit_aer import AerSimulator
-
-        backend = AerSimulator()
-        seed = 123
-        qc = RealAmplitudes(num_qubits=2, reps=1)
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        qc = pm.run(qc)
-        op = [SparsePauliOp("IX"), SparsePauliOp("YI")]
-        shape = (3, 2)
-        params_array = self._rng.random(shape + (qc.num_parameters,))
-        params_list = params_array.tolist()
-        params_list_array = list(params_array)
-        statevector_estimator = StatevectorEstimator(seed=seed)
-        target = statevector_estimator.run([(qc, op, params_list)]).result()
-
-        backend_estimator = BackendEstimatorV2(backend=backend, options=self._options)
-        backend_estimator.options.abelian_grouping = abelian_grouping
-
-        with self.subTest("ndarrary"):
-            result = backend_estimator.run([(qc, op, params_array)]).result()
-            self.assertEqual(result[0].data.evs.shape, shape)
-            np.testing.assert_allclose(
-                result[0].data.evs, target[0].data.evs, rtol=self._rtol, atol=1e-1
-            )
-
-        with self.subTest("list of ndarray"):
-            result = backend_estimator.run([(qc, op, params_list_array)]).result()
-            self.assertEqual(result[0].data.evs.shape, shape)
-            np.testing.assert_allclose(
-                result[0].data.evs, target[0].data.evs, rtol=self._rtol, atol=1e-1
-            )
-
-
-if __name__ == "__main__":
-    unittest.main()
diff --git a/test/python/primitives/test_backend_sampler.py b/test/python/primitives/test_backend_sampler.py
index b455e6b5d..e4ff7478d 100644
--- a/test/python/primitives/test_backend_sampler.py
+++ b/test/python/primitives/test_backend_sampler.py
@@ -259,8 +259,7 @@ class TestBackendSampler(QiskitTestCase):
         qc = RealAmplitudes(num_qubits=2, reps=2)
         qc.measure_all()
         k = 5
-        rng = np.random.default_rng(12)
-        params_array = rng.random((k, qc.num_parameters))
+        params_array = np.random.rand(k, qc.num_parameters)
         params_list = params_array.tolist()
         params_list_array = list(params_array)
         sampler = BackendSampler(backend=backend)
diff --git a/test/python/primitives/test_backend_sampler_v2.py b/test/python/primitives/test_backend_sampler_v2.py
deleted file mode 100644
index 6e1579c2f..000000000
--- a/test/python/primitives/test_backend_sampler_v2.py
+++ /dev/null
@@ -1,661 +0,0 @@
-# This code is part of Qiskit.
-#
-# (C) Copyright IBM 2024.
-#
-# This code is licensed under the Apache License, Version 2.0. You may
-# obtain a copy of this license in the LICENSE.txt file in the root directory
-# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
-#
-# Any modifications or derivative works of this code must retain this
-# copyright notice, and modified files need to carry a notice indicating
-# that they have been altered from the originals.
-
-"""Tests for Backend Sampler V2."""
-
-from __future__ import annotations
-
-import unittest
-from dataclasses import astuple
-from test import QiskitTestCase, combine
-
-import numpy as np
-from ddt import ddt
-from numpy.typing import NDArray
-
-from qiskit import ClassicalRegister, QuantumCircuit, QuantumRegister
-from qiskit.circuit import Parameter
-from qiskit.circuit.library import RealAmplitudes, UnitaryGate
-from qiskit.primitives import PrimitiveResult, PubResult, StatevectorSampler
-from qiskit.primitives.backend_sampler_v2 import BackendSamplerV2
-from qiskit.primitives.containers import BitArray
-from qiskit.primitives.containers.data_bin import DataBin
-from qiskit.primitives.containers.sampler_pub import SamplerPub
-from qiskit.providers import JobStatus
-from qiskit.providers.backend_compat import BackendV2Converter
-from qiskit.providers.basic_provider import BasicSimulator
-from qiskit.providers.fake_provider import Fake7QPulseV1
-from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
-
-BACKENDS = [BasicSimulator(), Fake7QPulseV1(), BackendV2Converter(Fake7QPulseV1())]
-
-
-@ddt
-class TestBackendSamplerV2(QiskitTestCase):
-    """Test for BackendSamplerV2"""
-
-    def setUp(self):
-        super().setUp()
-        self._shots = 10000
-        self._seed = 123
-        self._options = {"default_shots": self._shots, "seed_simulator": self._seed}
-
-        self._cases = []
-        hadamard = QuantumCircuit(1, 1, name="Hadamard")
-        hadamard.h(0)
-        hadamard.measure(0, 0)
-        self._cases.append((hadamard, None, {0: 5000, 1: 5000}))  # case 0
-
-        bell = QuantumCircuit(2, name="Bell")
-        bell.h(0)
-        bell.cx(0, 1)
-        bell.measure_all()
-        self._cases.append((bell, None, {0: 5000, 3: 5000}))  # case 1
-
-        pqc = RealAmplitudes(num_qubits=2, reps=2)
-        pqc.measure_all()
-        self._cases.append((pqc, [0] * 6, {0: 10000}))  # case 2
-        self._cases.append((pqc, [1] * 6, {0: 168, 1: 3389, 2: 470, 3: 5973}))  # case 3
-        self._cases.append((pqc, [0, 1, 1, 2, 3, 5], {0: 1339, 1: 3534, 2: 912, 3: 4215}))  # case 4
-        self._cases.append((pqc, [1, 2, 3, 4, 5, 6], {0: 634, 1: 291, 2: 6039, 3: 3036}))  # case 5
-
-        pqc2 = RealAmplitudes(num_qubits=2, reps=3)
-        pqc2.measure_all()
-        self._cases.append(
-            (pqc2, [0, 1, 2, 3, 4, 5, 6, 7], {0: 1898, 1: 6864, 2: 928, 3: 311})
-        )  # case 6
-
-    def _assert_allclose(self, bitarray: BitArray, target: NDArray | BitArray, rtol=1e-1, atol=5e2):
-        self.assertEqual(bitarray.shape, target.shape)
-        for idx in np.ndindex(bitarray.shape):
-            int_counts = bitarray.get_int_counts(idx)
-            target_counts = (
-                target.get_int_counts(idx) if isinstance(target, BitArray) else target[idx]
-            )
-            max_key = max(max(int_counts.keys()), max(target_counts.keys()))
-            ary = np.array([int_counts.get(i, 0) for i in range(max_key + 1)])
-            tgt = np.array([target_counts.get(i, 0) for i in range(max_key + 1)])
-            np.testing.assert_allclose(ary, tgt, rtol=rtol, atol=atol, err_msg=f"index: {idx}")
-
-    @combine(backend=BACKENDS)
-    def test_sampler_run(self, backend):
-        """Test run()."""
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-
-        with self.subTest("single"):
-            bell, _, target = self._cases[1]
-            bell = pm.run(bell)
-            sampler = BackendSamplerV2(backend=backend, options=self._options)
-            job = sampler.run([bell], shots=self._shots)
-            result = job.result()
-            self.assertIsInstance(result, PrimitiveResult)
-            self.assertIsInstance(result.metadata, dict)
-            self.assertEqual(len(result), 1)
-            self.assertIsInstance(result[0], PubResult)
-            self.assertIsInstance(result[0].data, DataBin)
-            self.assertIsInstance(result[0].data.meas, BitArray)
-            self._assert_allclose(result[0].data.meas, np.array(target))
-
-        with self.subTest("single with param"):
-            pqc, param_vals, target = self._cases[2]
-            sampler = BackendSamplerV2(backend=backend, options=self._options)
-            pqc = pm.run(pqc)
-            params = (param.name for param in pqc.parameters)
-            job = sampler.run([(pqc, {params: param_vals})], shots=self._shots)
-            result = job.result()
-            self.assertIsInstance(result, PrimitiveResult)
-            self.assertIsInstance(result.metadata, dict)
-            self.assertEqual(len(result), 1)
-            self.assertIsInstance(result[0], PubResult)
-            self.assertIsInstance(result[0].data, DataBin)
-            self.assertIsInstance(result[0].data.meas, BitArray)
-            self._assert_allclose(result[0].data.meas, np.array(target))
-
-        with self.subTest("multiple"):
-            pqc, param_vals, target = self._cases[2]
-            sampler = BackendSamplerV2(backend=backend, options=self._options)
-            pqc = pm.run(pqc)
-            params = (param.name for param in pqc.parameters)
-            job = sampler.run(
-                [(pqc, {params: [param_vals, param_vals, param_vals]})], shots=self._shots
-            )
-            result = job.result()
-            self.assertIsInstance(result, PrimitiveResult)
-            self.assertIsInstance(result.metadata, dict)
-            self.assertEqual(len(result), 1)
-            self.assertIsInstance(result[0], PubResult)
-            self.assertIsInstance(result[0].data, DataBin)
-            self.assertIsInstance(result[0].data.meas, BitArray)
-            self._assert_allclose(result[0].data.meas, np.array([target, target, target]))
-
-    @combine(backend=BACKENDS)
-    def test_sampler_run_multiple_times(self, backend):
-        """Test run() returns the same results if the same input is given."""
-        bell, _, _ = self._cases[1]
-        sampler = BackendSamplerV2(backend=backend, options=self._options)
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        bell = pm.run(bell)
-        result1 = sampler.run([bell], shots=self._shots).result()
-        meas1 = result1[0].data.meas
-        result2 = sampler.run([bell], shots=self._shots).result()
-        meas2 = result2[0].data.meas
-        self._assert_allclose(meas1, meas2, rtol=0)
-
-    @combine(backend=BACKENDS)
-    def test_sample_run_multiple_circuits(self, backend):
-        """Test run() with multiple circuits."""
-        bell, _, target = self._cases[1]
-        sampler = BackendSamplerV2(backend=backend, options=self._options)
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        bell = pm.run(bell)
-        result = sampler.run([bell, bell, bell], shots=self._shots).result()
-        self.assertEqual(len(result), 3)
-        self._assert_allclose(result[0].data.meas, np.array(target))
-        self._assert_allclose(result[1].data.meas, np.array(target))
-        self._assert_allclose(result[2].data.meas, np.array(target))
-
-    @combine(backend=BACKENDS)
-    def test_sampler_run_with_parameterized_circuits(self, backend):
-        """Test run() with parameterized circuits."""
-        pqc1, param1, target1 = self._cases[4]
-        pqc2, param2, target2 = self._cases[5]
-        pqc3, param3, target3 = self._cases[6]
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        pqc1, pqc2, pqc3 = pm.run([pqc1, pqc2, pqc3])
-
-        sampler = BackendSamplerV2(backend=backend, options=self._options)
-        result = sampler.run(
-            [(pqc1, param1), (pqc2, param2), (pqc3, param3)], shots=self._shots
-        ).result()
-        self.assertEqual(len(result), 3)
-        self._assert_allclose(result[0].data.meas, np.array(target1))
-        self._assert_allclose(result[1].data.meas, np.array(target2))
-        self._assert_allclose(result[2].data.meas, np.array(target3))
-
-    @combine(backend=BACKENDS)
-    def test_run_1qubit(self, backend):
-        """test for 1-qubit cases"""
-        qc = QuantumCircuit(1)
-        qc.measure_all()
-        qc2 = QuantumCircuit(1)
-        qc2.x(0)
-        qc2.measure_all()
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        qc, qc2 = pm.run([qc, qc2])
-
-        sampler = BackendSamplerV2(backend=backend, options=self._options)
-        result = sampler.run([qc, qc2], shots=self._shots).result()
-        self.assertEqual(len(result), 2)
-        for i in range(2):
-            self._assert_allclose(result[i].data.meas, np.array({i: self._shots}))
-
-    @combine(backend=BACKENDS)
-    def test_run_2qubit(self, backend):
-        """test for 2-qubit cases"""
-        qc0 = QuantumCircuit(2)
-        qc0.measure_all()
-        qc1 = QuantumCircuit(2)
-        qc1.x(0)
-        qc1.measure_all()
-        qc2 = QuantumCircuit(2)
-        qc2.x(1)
-        qc2.measure_all()
-        qc3 = QuantumCircuit(2)
-        qc3.x([0, 1])
-        qc3.measure_all()
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        qc0, qc1, qc2, qc3 = pm.run([qc0, qc1, qc2, qc3])
-
-        sampler = BackendSamplerV2(backend=backend, options=self._options)
-        result = sampler.run([qc0, qc1, qc2, qc3], shots=self._shots).result()
-        self.assertEqual(len(result), 4)
-        for i in range(4):
-            self._assert_allclose(result[i].data.meas, np.array({i: self._shots}))
-
-    @combine(backend=BACKENDS)
-    def test_run_single_circuit(self, backend):
-        """Test for single circuit case."""
-        sampler = BackendSamplerV2(backend=backend, options=self._options)
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-
-        with self.subTest("No parameter"):
-            circuit, _, target = self._cases[1]
-            circuit = pm.run(circuit)
-            param_target = [
-                (None, np.array(target)),
-                ({}, np.array(target)),
-            ]
-            for param, target in param_target:
-                with self.subTest(f"{circuit.name} w/ {param}"):
-                    result = sampler.run([(circuit, param)], shots=self._shots).result()
-                    self.assertEqual(len(result), 1)
-                    self._assert_allclose(result[0].data.meas, target)
-
-        with self.subTest("One parameter"):
-            circuit = QuantumCircuit(1, 1, name="X gate")
-            param = Parameter("x")
-            circuit.ry(param, 0)
-            circuit.measure(0, 0)
-            circuit = pm.run(circuit)
-            param_target = [
-                ({"x": np.pi}, np.array({1: self._shots})),
-                ({param: np.pi}, np.array({1: self._shots})),
-                ({"x": np.array(np.pi)}, np.array({1: self._shots})),
-                ({param: np.array(np.pi)}, np.array({1: self._shots})),
-                ({"x": [np.pi]}, np.array({1: self._shots})),
-                ({param: [np.pi]}, np.array({1: self._shots})),
-                ({"x": np.array([np.pi])}, np.array({1: self._shots})),
-                ({param: np.array([np.pi])}, np.array({1: self._shots})),
-            ]
-            for param, target in param_target:
-                with self.subTest(f"{circuit.name} w/ {param}"):
-                    result = sampler.run([(circuit, param)], shots=self._shots).result()
-                    self.assertEqual(len(result), 1)
-                    self._assert_allclose(result[0].data.c, target)
-
-        with self.subTest("More than one parameter"):
-            circuit, param, target = self._cases[3]
-            circuit = pm.run(circuit)
-            param_target = [
-                (param, np.array(target)),
-                (tuple(param), np.array(target)),
-                (np.array(param), np.array(target)),
-                ((param,), np.array([target])),
-                ([param], np.array([target])),
-                (np.array([param]), np.array([target])),
-            ]
-            for param, target in param_target:
-                with self.subTest(f"{circuit.name} w/ {param}"):
-                    result = sampler.run([(circuit, param)], shots=self._shots).result()
-                    self.assertEqual(len(result), 1)
-                    self._assert_allclose(result[0].data.meas, target)
-
-    @combine(backend=BACKENDS)
-    def test_run_reverse_meas_order(self, backend):
-        """test for sampler with reverse measurement order"""
-        x = Parameter("x")
-        y = Parameter("y")
-
-        qc = QuantumCircuit(3, 3)
-        qc.rx(x, 0)
-        qc.rx(y, 1)
-        qc.x(2)
-        qc.measure(0, 2)
-        qc.measure(1, 1)
-        qc.measure(2, 0)
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        qc = pm.run(qc)
-
-        sampler = BackendSamplerV2(backend=backend)
-        sampler.options.seed_simulator = self._seed
-        result = sampler.run([(qc, [0, 0]), (qc, [np.pi / 2, 0])], shots=self._shots).result()
-        self.assertEqual(len(result), 2)
-
-        # qc({x: 0, y: 0})
-        self._assert_allclose(result[0].data.c, np.array({1: self._shots}))
-
-        # qc({x: pi/2, y: 0})
-        self._assert_allclose(result[1].data.c, np.array({1: self._shots / 2, 5: self._shots / 2}))
-
-    @combine(backend=BACKENDS)
-    def test_run_errors(self, backend):
-        """Test for errors with run method"""
-        qc1 = QuantumCircuit(1)
-        qc1.measure_all()
-        qc2 = RealAmplitudes(num_qubits=1, reps=1)
-        qc2.measure_all()
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        qc1, qc2 = pm.run([qc1, qc2])
-
-        sampler = BackendSamplerV2(backend=backend)
-        with self.subTest("set parameter values to a non-parameterized circuit"):
-            with self.assertRaises(ValueError):
-                _ = sampler.run([(qc1, [1e2])]).result()
-        with self.subTest("missing all parameter values for a parameterized circuit"):
-            with self.assertRaises(ValueError):
-                _ = sampler.run([qc2]).result()
-            with self.assertRaises(ValueError):
-                _ = sampler.run([(qc2, [])]).result()
-            with self.assertRaises(ValueError):
-                _ = sampler.run([(qc2, None)]).result()
-        with self.subTest("missing some parameter values for a parameterized circuit"):
-            with self.assertRaises(ValueError):
-                _ = sampler.run([(qc2, [1e2])]).result()
-        with self.subTest("too many parameter values for a parameterized circuit"):
-            with self.assertRaises(ValueError):
-                _ = sampler.run([(qc2, [1e2] * 100)]).result()
-        with self.subTest("negative shots, run arg"):
-            with self.assertRaises(ValueError):
-                _ = sampler.run([qc1], shots=-1).result()
-        with self.subTest("negative shots, pub-like"):
-            with self.assertRaises(ValueError):
-                _ = sampler.run([(qc1, None, -1)]).result()
-        with self.subTest("negative shots, pub"):
-            with self.assertRaises(ValueError):
-                _ = sampler.run([SamplerPub(qc1, shots=-1)]).result()
-        with self.subTest("zero shots, run arg"):
-            with self.assertRaises(ValueError):
-                _ = sampler.run([qc1], shots=0).result()
-        with self.subTest("zero shots, pub-like"):
-            with self.assertRaises(ValueError):
-                _ = sampler.run([(qc1, None, 0)]).result()
-        with self.subTest("zero shots, pub"):
-            with self.assertRaises(ValueError):
-                _ = sampler.run([SamplerPub(qc1, shots=0)]).result()
-        with self.subTest("missing []"):
-            with self.assertRaisesRegex(ValueError, "An invalid Sampler pub-like was given"):
-                _ = sampler.run(qc1).result()
-        with self.subTest("missing [] for pqc"):
-            with self.assertRaisesRegex(ValueError, "Note that if you want to run a single pub,"):
-                _ = sampler.run((qc2, [0, 1])).result()
-
-    @combine(backend=BACKENDS)
-    def test_run_empty_parameter(self, backend):
-        """Test for empty parameter"""
-        n = 5
-        qc = QuantumCircuit(n, n - 1)
-        qc.measure(range(n - 1), range(n - 1))
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        qc = pm.run(qc)
-        sampler = BackendSamplerV2(backend=backend, options=self._options)
-        with self.subTest("one circuit"):
-            result = sampler.run([qc], shots=self._shots).result()
-            self.assertEqual(len(result), 1)
-            self._assert_allclose(result[0].data.c, np.array({0: self._shots}))
-
-        with self.subTest("two circuits"):
-            result = sampler.run([qc, qc], shots=self._shots).result()
-            self.assertEqual(len(result), 2)
-            for i in range(2):
-                self._assert_allclose(result[i].data.c, np.array({0: self._shots}))
-
-    @combine(backend=BACKENDS)
-    def test_run_numpy_params(self, backend):
-        """Test for numpy array as parameter values"""
-        qc = RealAmplitudes(num_qubits=2, reps=2)
-        qc.measure_all()
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        qc = pm.run(qc)
-        k = 5
-        params_array = np.linspace(0, 1, k * qc.num_parameters).reshape((k, qc.num_parameters))
-        params_list = params_array.tolist()
-        sampler = StatevectorSampler(seed=self._seed)
-        target = sampler.run([(qc, params_list)], shots=self._shots).result()
-
-        with self.subTest("ndarray"):
-            sampler = BackendSamplerV2(backend=backend, options=self._options)
-            result = sampler.run([(qc, params_array)], shots=self._shots).result()
-            self.assertEqual(len(result), 1)
-            self._assert_allclose(result[0].data.meas, target[0].data.meas)
-
-        with self.subTest("split a list"):
-            sampler = BackendSamplerV2(backend=backend, options=self._options)
-            result = sampler.run(
-                [(qc, params) for params in params_list], shots=self._shots
-            ).result()
-            self.assertEqual(len(result), k)
-            for i in range(k):
-                self._assert_allclose(
-                    result[i].data.meas, np.array(target[0].data.meas.get_int_counts(i))
-                )
-
-    @combine(backend=BACKENDS)
-    def test_run_with_shots_option(self, backend):
-        """test with shots option."""
-        bell, _, _ = self._cases[1]
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        bell = pm.run(bell)
-        shots = 100
-
-        with self.subTest("run arg"):
-            sampler = BackendSamplerV2(backend=backend, options=self._options)
-            result = sampler.run([bell], shots=shots).result()
-            self.assertEqual(len(result), 1)
-            self.assertEqual(result[0].data.meas.num_shots, shots)
-            self.assertEqual(sum(result[0].data.meas.get_counts().values()), shots)
-
-        with self.subTest("default shots"):
-            sampler = BackendSamplerV2(backend=backend, options=self._options)
-            default_shots = sampler.options.default_shots
-            result = sampler.run([bell]).result()
-            self.assertEqual(len(result), 1)
-            self.assertEqual(result[0].data.meas.num_shots, default_shots)
-            self.assertEqual(sum(result[0].data.meas.get_counts().values()), default_shots)
-
-        with self.subTest("setting default shots"):
-            default_shots = 100
-            sampler = BackendSamplerV2(backend=backend, options=self._options)
-            sampler.options.default_shots = default_shots
-            self.assertEqual(sampler.options.default_shots, default_shots)
-            result = sampler.run([bell]).result()
-            self.assertEqual(len(result), 1)
-            self.assertEqual(result[0].data.meas.num_shots, default_shots)
-            self.assertEqual(sum(result[0].data.meas.get_counts().values()), default_shots)
-
-        with self.subTest("pub-like"):
-            sampler = BackendSamplerV2(backend=backend, options=self._options)
-            result = sampler.run([(bell, None, shots)]).result()
-            self.assertEqual(len(result), 1)
-            self.assertEqual(result[0].data.meas.num_shots, shots)
-            self.assertEqual(sum(result[0].data.meas.get_counts().values()), shots)
-
-        with self.subTest("pub"):
-            sampler = BackendSamplerV2(backend=backend, options=self._options)
-            result = sampler.run([SamplerPub(bell, shots=shots)]).result()
-            self.assertEqual(len(result), 1)
-            self.assertEqual(result[0].data.meas.num_shots, shots)
-            self.assertEqual(sum(result[0].data.meas.get_counts().values()), shots)
-
-        with self.subTest("multiple pubs"):
-            sampler = BackendSamplerV2(backend=backend, options=self._options)
-            shots1 = 100
-            shots2 = 200
-            result = sampler.run(
-                [
-                    SamplerPub(bell, shots=shots1),
-                    SamplerPub(bell, shots=shots2),
-                ],
-                shots=self._shots,
-            ).result()
-            self.assertEqual(len(result), 2)
-            self.assertEqual(result[0].data.meas.num_shots, shots1)
-            self.assertEqual(sum(result[0].data.meas.get_counts().values()), shots1)
-            self.assertEqual(result[1].data.meas.num_shots, shots2)
-            self.assertEqual(sum(result[1].data.meas.get_counts().values()), shots2)
-
-    @combine(backend=BACKENDS)
-    def test_run_shots_result_size(self, backend):
-        """test with shots option to validate the result size"""
-        n = 7  # should be less than or equal to the number of qubits of backend
-        qc = QuantumCircuit(n)
-        qc.h(range(n))
-        qc.measure_all()
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        qc = pm.run(qc)
-        sampler = BackendSamplerV2(backend=backend, options=self._options)
-        result = sampler.run([qc], shots=self._shots).result()
-        self.assertEqual(len(result), 1)
-        self.assertLessEqual(result[0].data.meas.num_shots, self._shots)
-        self.assertEqual(sum(result[0].data.meas.get_counts().values()), self._shots)
-
-    @combine(backend=BACKENDS)
-    def test_primitive_job_status_done(self, backend):
-        """test primitive job's status"""
-        bell, _, _ = self._cases[1]
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        bell = pm.run(bell)
-        sampler = BackendSamplerV2(backend=backend, options=self._options)
-        job = sampler.run([bell], shots=self._shots)
-        _ = job.result()
-        self.assertEqual(job.status(), JobStatus.DONE)
-
-    @combine(backend=BACKENDS)
-    def test_circuit_with_unitary(self, backend):
-        """Test for circuit with unitary gate."""
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-
-        with self.subTest("identity"):
-            gate = UnitaryGate(np.eye(2))
-
-            circuit = QuantumCircuit(1)
-            circuit.append(gate, [0])
-            circuit.measure_all()
-            circuit = pm.run(circuit)
-
-            sampler = BackendSamplerV2(backend=backend, options=self._options)
-            result = sampler.run([circuit], shots=self._shots).result()
-            self.assertEqual(len(result), 1)
-            self._assert_allclose(result[0].data.meas, np.array({0: self._shots}))
-
-        with self.subTest("X"):
-            gate = UnitaryGate([[0, 1], [1, 0]])
-
-            circuit = QuantumCircuit(1)
-            circuit.append(gate, [0])
-            circuit.measure_all()
-            circuit = pm.run(circuit)
-
-            sampler = BackendSamplerV2(backend=backend, options=self._options)
-            result = sampler.run([circuit], shots=self._shots).result()
-            self.assertEqual(len(result), 1)
-            self._assert_allclose(result[0].data.meas, np.array({1: self._shots}))
-
-    @combine(backend=BACKENDS)
-    def test_circuit_with_multiple_cregs(self, backend):
-        """Test for circuit with multiple classical registers."""
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        cases = []
-
-        # case 1
-        a = ClassicalRegister(1, "a")
-        b = ClassicalRegister(2, "b")
-        c = ClassicalRegister(3, "c")
-
-        qc = QuantumCircuit(QuantumRegister(3), a, b, c)
-        qc.h(range(3))
-        qc.measure([0, 1, 2, 2], [0, 2, 4, 5])
-        qc = pm.run(qc)
-        target = {"a": {0: 5000, 1: 5000}, "b": {0: 5000, 2: 5000}, "c": {0: 5000, 6: 5000}}
-        cases.append(("use all cregs", qc, target))
-
-        # case 2
-        a = ClassicalRegister(1, "a")
-        b = ClassicalRegister(5, "b")
-        c = ClassicalRegister(3, "c")
-
-        qc = QuantumCircuit(QuantumRegister(3), a, b, c)
-        qc.h(range(3))
-        qc.measure([0, 1, 2, 2], [0, 2, 4, 5])
-        qc = pm.run(qc)
-        target = {
-            "a": {0: 5000, 1: 5000},
-            "b": {0: 2500, 2: 2500, 24: 2500, 26: 2500},
-            "c": {0: 10000},
-        }
-        cases.append(("use only a and b", qc, target))
-
-        # case 3
-        a = ClassicalRegister(1, "a")
-        b = ClassicalRegister(2, "b")
-        c = ClassicalRegister(3, "c")
-
-        qc = QuantumCircuit(QuantumRegister(3), a, b, c)
-        qc.h(range(3))
-        qc.measure(1, 5)
-        qc = pm.run(qc)
-        target = {"a": {0: 10000}, "b": {0: 10000}, "c": {0: 5000, 4: 5000}}
-        cases.append(("use only c", qc, target))
-
-        # case 4
-        a = ClassicalRegister(1, "a")
-        b = ClassicalRegister(2, "b")
-        c = ClassicalRegister(3, "c")
-
-        qc = QuantumCircuit(QuantumRegister(3), a, b, c)
-        qc.h(range(3))
-        qc.measure([0, 1, 2], [5, 5, 5])
-        qc = pm.run(qc)
-        target = {"a": {0: 10000}, "b": {0: 10000}, "c": {0: 5000, 4: 5000}}
-        cases.append(("use only c multiple qubits", qc, target))
-
-        # case 5
-        a = ClassicalRegister(1, "a")
-        b = ClassicalRegister(2, "b")
-        c = ClassicalRegister(3, "c")
-
-        qc = QuantumCircuit(QuantumRegister(3), a, b, c)
-        qc.h(range(3))
-        qc = pm.run(qc)
-        target = {"a": {0: 10000}, "b": {0: 10000}, "c": {0: 10000}}
-        cases.append(("no measure", qc, target))
-
-        for title, qc, target in cases:
-            with self.subTest(title):
-                sampler = BackendSamplerV2(backend=backend, options=self._options)
-                result = sampler.run([qc], shots=self._shots).result()
-                self.assertEqual(len(result), 1)
-                data = result[0].data
-                self.assertEqual(len(astuple(data)), 3)
-                for creg in qc.cregs:
-                    self.assertTrue(hasattr(data, creg.name))
-                    self._assert_allclose(getattr(data, creg.name), np.array(target[creg.name]))
-
-    @combine(backend=BACKENDS)
-    def test_circuit_with_aliased_cregs(self, backend):
-        """Test for circuit with aliased classical registers."""
-        q = QuantumRegister(3, "q")
-        c1 = ClassicalRegister(1, "c1")
-        c2 = ClassicalRegister(1, "c2")
-
-        qc = QuantumCircuit(q, c1, c2)
-        qc.ry(np.pi / 4, 2)
-        qc.cx(2, 1)
-        qc.cx(0, 1)
-        qc.h(0)
-        qc.measure(0, c1)
-        qc.measure(1, c2)
-        qc.z(2).c_if(c1, 1)
-        qc.x(2).c_if(c2, 1)
-        qc2 = QuantumCircuit(5, 5)
-        qc2.compose(qc, [0, 2, 3], [2, 4], inplace=True)
-        cregs = [creg.name for creg in qc2.cregs]
-        target = {
-            cregs[0]: {0: 4255, 4: 4297, 16: 720, 20: 726},
-            cregs[1]: {0: 5000, 1: 5000},
-            cregs[2]: {0: 8500, 1: 1500},
-        }
-
-        sampler = BackendSamplerV2(backend=backend, options=self._options)
-        pm = generate_preset_pass_manager(optimization_level=0, backend=backend)
-        qc2 = pm.run(qc2)
-        result = sampler.run([qc2], shots=self._shots).result()
-        self.assertEqual(len(result), 1)
-        data = result[0].data
-        self.assertEqual(len(astuple(data)), 3)
-        for creg_name in target:
-            self.assertTrue(hasattr(data, creg_name))
-            self._assert_allclose(getattr(data, creg_name), np.array(target[creg_name]))
-
-    @combine(backend=BACKENDS)
-    def test_no_cregs(self, backend):
-        """Test that the sampler works when there are no classical register in the circuit."""
-        qc = QuantumCircuit(2)
-        sampler = BackendSamplerV2(backend=backend, options=self._options)
-        with self.assertWarns(UserWarning):
-            result = sampler.run([qc]).result()
-
-        self.assertEqual(len(result), 1)
-        self.assertEqual(len(result[0].data), 0)
-
-
-if __name__ == "__main__":
-    unittest.main()
diff --git a/test/python/primitives/test_estimator.py b/test/python/primitives/test_estimator.py
index 80045dee0..e9a8516c2 100644
--- a/test/python/primitives/test_estimator.py
+++ b/test/python/primitives/test_estimator.py
@@ -75,7 +75,7 @@ class TestEstimator(QiskitTestCase):
         # Note that passing objects has an overhead
         # since the corresponding indices need to be searched.
         # User can append a circuit and observable.
-        # calculate [ <psi2(theta2)|H1|psi2(theta2)> ]
+        # calculate [ <psi2(theta2)|H2|psi2(theta2)> ]
         result2 = estimator.run([psi2], [hamiltonian1], [theta2]).result()
         np.testing.assert_allclose(result2.values, [2.97797666])
 
@@ -237,8 +237,7 @@ class TestEstimator(QiskitTestCase):
         qc = RealAmplitudes(num_qubits=2, reps=2)
         op = SparsePauliOp.from_list([("IZ", 1), ("XI", 2), ("ZY", -1)])
         k = 5
-        rng = np.random.default_rng(12)
-        params_array = rng.random((k, qc.num_parameters))
+        params_array = np.random.rand(k, qc.num_parameters)
         params_list = params_array.tolist()
         params_list_array = list(params_array)
         estimator = Estimator()
diff --git a/test/python/primitives/test_sampler.py b/test/python/primitives/test_sampler.py
index eac0886b3..1ebfed5e2 100644
--- a/test/python/primitives/test_sampler.py
+++ b/test/python/primitives/test_sampler.py
@@ -324,8 +324,7 @@ class TestSampler(QiskitTestCase):
         qc = RealAmplitudes(num_qubits=2, reps=2)
         qc.measure_all()
         k = 5
-        rng = np.random.default_rng(12)
-        params_array = rng.random((k, qc.num_parameters))
+        params_array = np.random.rand(k, qc.num_parameters)
         params_list = params_array.tolist()
         params_list_array = list(params_array)
         sampler = Sampler()
diff --git a/test/python/primitives/test_statevector_estimator.py b/test/python/primitives/test_statevector_estimator.py
index 15c022f77..1c2621acd 100644
--- a/test/python/primitives/test_statevector_estimator.py
+++ b/test/python/primitives/test_statevector_estimator.py
@@ -73,7 +73,7 @@ class TestStatevectorEstimator(QiskitTestCase):
         # Note that passing objects has an overhead
         # since the corresponding indices need to be searched.
         # User can append a circuit and observable.
-        # calculate [ <psi2(theta2)|H1|psi2(theta2)> ]
+        # calculate [ <psi2(theta2)|H2|psi2(theta2)> ]
         result2 = estimator.run([(psi2, hamiltonian1, theta2)]).result()
         np.testing.assert_allclose(result2[0].data.evs, [2.97797666])
 
@@ -236,17 +236,13 @@ class TestStatevectorEstimator(QiskitTestCase):
             est.run([(qc, op)], precision=-1).result()
         with self.assertRaises(ValueError):
             est.run([(qc, 1j * op)], precision=0.1).result()
-        with self.subTest("missing []"):
-            with self.assertRaisesRegex(ValueError, "An invalid Estimator pub-like was given"):
-                _ = est.run((qc, op)).result()
 
     def test_run_numpy_params(self):
         """Test for numpy array as parameter values"""
         qc = RealAmplitudes(num_qubits=2, reps=2)
         op = SparsePauliOp.from_list([("IZ", 1), ("XI", 2), ("ZY", -1)])
         k = 5
-        rng = np.random.default_rng(12)
-        params_array = rng.random((k, qc.num_parameters))
+        params_array = np.random.rand(k, qc.num_parameters)
         params_list = params_array.tolist()
         params_list_array = list(params_array)
         estimator = StatevectorEstimator()
diff --git a/test/python/primitives/test_statevector_sampler.py b/test/python/primitives/test_statevector_sampler.py
index cd0622b18..0ae87bd78 100644
--- a/test/python/primitives/test_statevector_sampler.py
+++ b/test/python/primitives/test_statevector_sampler.py
@@ -320,12 +320,6 @@ class TestStatevectorSampler(QiskitTestCase):
         with self.subTest("zero shots, pub"):
             with self.assertRaises(ValueError):
                 _ = sampler.run([SamplerPub(qc1, shots=0)]).result()
-        with self.subTest("missing []"):
-            with self.assertRaisesRegex(ValueError, "An invalid Sampler pub-like was given"):
-                _ = sampler.run(qc1).result()
-        with self.subTest("missing [] for pqc"):
-            with self.assertRaisesRegex(ValueError, "Note that if you want to run a single pub,"):
-                _ = sampler.run((qc2, [0, 1])).result()
 
     def test_run_empty_parameter(self):
         """Test for empty parameter"""
diff --git a/test/python/pulse/test_builder.py b/test/python/pulse/test_builder.py
index cf029d5d9..6ec508976 100644
--- a/test/python/pulse/test_builder.py
+++ b/test/python/pulse/test_builder.py
@@ -21,7 +21,6 @@ from qiskit.pulse.instructions import directives
 from qiskit.pulse.transforms import target_qobj_transform
 from qiskit.providers.fake_provider import FakeOpenPulse2Q, Fake127QPulseV1
 from qiskit.pulse import library, instructions
-from qiskit.pulse.exceptions import PulseError
 from test import QiskitTestCase  # pylint: disable=wrong-import-order
 
 
@@ -107,29 +106,6 @@ class TestBuilderBase(TestBuilder):
 
         self.assertScheduleEqual(schedule, reference)
 
-    def test_default_alignment_alignmentkind_instance(self):
-        """Test default AlignmentKind instance"""
-        d0 = pulse.DriveChannel(0)
-        d1 = pulse.DriveChannel(0)
-
-        with pulse.build(default_alignment=pulse.transforms.AlignEquispaced(100)) as schedule:
-            pulse.delay(10, d0)
-            pulse.delay(20, d1)
-
-        with pulse.build() as reference:
-            with pulse.align_equispaced(100):
-                pulse.delay(10, d0)
-                pulse.delay(20, d1)
-
-        self.assertScheduleEqual(schedule, reference)
-
-    def test_unknown_string_identifier(self):
-        """Test that unknown string identifier raises an error"""
-
-        with self.assertRaises(PulseError):
-            with pulse.build(default_alignment="unknown") as _:
-                pass
-
 
 class TestContexts(TestBuilder):
     """Test builder contexts."""
diff --git a/test/python/pulse/test_parameter_manager.py b/test/python/pulse/test_parameter_manager.py
index 16cbc7bc8..baeb30e47 100644
--- a/test/python/pulse/test_parameter_manager.py
+++ b/test/python/pulse/test_parameter_manager.py
@@ -17,7 +17,6 @@
 from copy import deepcopy
 from unittest.mock import patch
 
-import ddt
 import numpy as np
 
 from qiskit import pulse
@@ -25,7 +24,6 @@ from qiskit.circuit import Parameter
 from qiskit.pulse.exceptions import PulseError, UnassignedDurationError
 from qiskit.pulse.parameter_manager import ParameterGetter, ParameterSetter
 from qiskit.pulse.transforms import AlignEquispaced, AlignLeft, inline_subroutines
-from qiskit.pulse.utils import format_parameter_value
 from test import QiskitTestCase  # pylint: disable=wrong-import-order
 
 
@@ -559,80 +557,3 @@ class TestScheduleTimeslots(QiskitTestCase):
         sched = pulse.Schedule()
         with self.assertRaises(UnassignedDurationError):
             sched.insert(0, test_play)
-
-
-@ddt.ddt
-class TestFormatParameter(QiskitTestCase):
-    """Test format_parameter_value function."""
-
-    def test_format_unassigned(self):
-        """Format unassigned parameter expression."""
-        p1 = Parameter("P1")
-        p2 = Parameter("P2")
-        expr = p1 + p2
-
-        self.assertEqual(format_parameter_value(expr), expr)
-
-    def test_partly_unassigned(self):
-        """Format partly assigned parameter expression."""
-        p1 = Parameter("P1")
-        p2 = Parameter("P2")
-        expr = (p1 + p2).assign(p1, 3.0)
-
-        self.assertEqual(format_parameter_value(expr), expr)
-
-    @ddt.data(1, 1.0, 1.00000000001, np.int64(1))
-    def test_integer(self, value):
-        """Format integer parameter expression."""
-        p1 = Parameter("P1")
-        expr = p1.assign(p1, value)
-        out = format_parameter_value(expr)
-        self.assertIsInstance(out, int)
-        self.assertEqual(out, 1)
-
-    @ddt.data(1.2, np.float64(1.2))
-    def test_float(self, value):
-        """Format float parameter expression."""
-        p1 = Parameter("P1")
-        expr = p1.assign(p1, value)
-        out = format_parameter_value(expr)
-        self.assertIsInstance(out, float)
-        self.assertEqual(out, 1.2)
-
-    @ddt.data(1.2 + 3.4j, np.complex128(1.2 + 3.4j))
-    def test_complex(self, value):
-        """Format float parameter expression."""
-        p1 = Parameter("P1")
-        expr = p1.assign(p1, value)
-        out = format_parameter_value(expr)
-        self.assertIsInstance(out, complex)
-        self.assertEqual(out, 1.2 + 3.4j)
-
-    def test_complex_rounding_error(self):
-        """Format float parameter expression."""
-        p1 = Parameter("P1")
-        expr = p1.assign(p1, 1.2 + 1j * 1e-20)
-        out = format_parameter_value(expr)
-        self.assertIsInstance(out, float)
-        self.assertEqual(out, 1.2)
-
-    def test_builtin_float(self):
-        """Format float parameter expression."""
-        expr = 1.23
-        out = format_parameter_value(expr)
-        self.assertIsInstance(out, float)
-        self.assertEqual(out, 1.23)
-
-    @ddt.data(15482812500000, 8465625000000, 4255312500000)
-    def test_edge_case(self, edge_case_val):
-        """Format integer parameter expression with
-        a particular integer number that causes rounding error at typecast."""
-
-        # Numbers to be tested here are chosen randomly.
-        # These numbers had caused mis-typecast into float before qiskit/#11972.
-
-        p1 = Parameter("P1")
-        expr = p1.assign(p1, edge_case_val)
-        out = format_parameter_value(expr)
-        self.assertIsInstance(out, int)
-        self.assertEqual(out, edge_case_val)
diff --git a/test/python/synthesis/test_synthesis.py b/test/python/synthesis/test_synthesis.py
index d3f8560cb..a5b360deb 100644
--- a/test/python/synthesis/test_synthesis.py
+++ b/test/python/synthesis/test_synthesis.py
@@ -56,6 +56,16 @@ from qiskit.quantum_info.random import random_unitary
 from qiskit.synthesis.one_qubit.one_qubit_decompose import OneQubitEulerDecomposer
 from qiskit.synthesis.two_qubit.two_qubit_decompose import (
     TwoQubitWeylDecomposition,
+    TwoQubitWeylIdEquiv,
+    TwoQubitWeylSWAPEquiv,
+    TwoQubitWeylPartialSWAPEquiv,
+    TwoQubitWeylPartialSWAPFlipEquiv,
+    TwoQubitWeylfSimaabEquiv,
+    TwoQubitWeylfSimabbEquiv,
+    TwoQubitWeylfSimabmbEquiv,
+    TwoQubitWeylControlledEquiv,
+    TwoQubitWeylMirrorControlledEquiv,
+    TwoQubitWeylGeneral,
     two_qubit_cnot_decompose,
     TwoQubitBasisDecomposer,
     TwoQubitControlledUDecomposer,
@@ -63,7 +73,6 @@ from qiskit.synthesis.two_qubit.two_qubit_decompose import (
     decompose_two_qubit_product_gate,
     TwoQubitDecomposeUpToDiagonal,
 )
-from qiskit._accelerate.two_qubit_decompose import Specialization
 from qiskit.synthesis.unitary import qsd
 from test import combine  # pylint: disable=wrong-import-order
 from test import QiskitTestCase  # pylint: disable=wrong-import-order
@@ -220,16 +229,8 @@ class CheckDecompositions(QiskitTestCase):
 
         # Loop to check both for implicit and explicity specialization
         for decomposer in (TwoQubitWeylDecomposition, expected_specialization):
-            if isinstance(decomposer, TwoQubitWeylDecomposition):
-                with self.assertDebugOnly():
-                    decomp = decomposer(target_unitary, fidelity=fidelity)
-                decomp_name = decomp.specialization
-            else:
-                with self.assertDebugOnly():
-                    decomp = TwoQubitWeylDecomposition(
-                        target_unitary, fidelity=None, _specialization=expected_specialization
-                    )
-                decomp_name = expected_specialization
+            with self.assertDebugOnly():
+                decomp = decomposer(target_unitary, fidelity=fidelity)
             self.assertRoundTrip(decomp)
             self.assertRoundTripPickle(decomp)
             self.assertEqual(
@@ -237,33 +238,27 @@ class CheckDecompositions(QiskitTestCase):
                 0,
                 "Incorrect saved unitary in the decomposition.",
             )
-            self.assertEqual(
-                decomp._inner_decomposition.specialization,
-                expected_specialization,
-                "Incorrect Weyl specialization.",
-            )
+            self.assertIsInstance(decomp, expected_specialization, "Incorrect Weyl specialization.")
             circ = decomp.circuit(simplify=True)
             self.assertDictEqual(
-                dict(circ.count_ops()), expected_gates, f"Gate counts of {decomp_name}"
+                dict(circ.count_ops()), expected_gates, f"Gate counts of {decomposer.__name__}"
             )
             actual_fid = decomp.actual_fidelity()
             self.assertAlmostEqual(decomp.calculated_fidelity, actual_fid, places=13)
-            self.assertGreaterEqual(actual_fid, fidelity, f"fidelity of {decomp_name}")
+            self.assertGreaterEqual(actual_fid, fidelity, f"fidelity of {decomposer.__name__}")
             actual_unitary = Operator(circ).data
             trace = np.trace(actual_unitary.T.conj() @ target_unitary)
-            self.assertAlmostEqual(trace.imag, 0, places=13, msg=f"Real trace for {decomp_name}")
+            self.assertAlmostEqual(
+                trace.imag, 0, places=13, msg=f"Real trace for {decomposer.__name__}"
+            )
         with self.assertDebugOnly():
-            decomp2 = TwoQubitWeylDecomposition(
-                target_unitary, fidelity=None, _specialization=expected_specialization
-            )  # Shouldn't raise
+            decomp2 = expected_specialization(target_unitary, fidelity=None)  # Shouldn't raise
         self.assertRoundTrip(decomp2)
         self.assertRoundTripPickle(decomp2)
-        if expected_specialization != Specialization.General:
+        if expected_specialization is not TwoQubitWeylGeneral:
             with self.assertRaises(QiskitError) as exc:
-                _ = TwoQubitWeylDecomposition(
-                    target_unitary, fidelity=1.0, _specialization=expected_specialization
-                )
-            self.assertIn("worse than requested", str(exc.exception))
+                _ = expected_specialization(target_unitary, fidelity=1.0)
+            self.assertIn("worse than requested", exc.exception.message)
 
     def check_exact_decomposition(
         self, target_unitary, decomposer, tolerance=1.0e-12, num_basis_uses=None
@@ -833,7 +828,7 @@ class TestTwoQubitWeylDecompositionSpecialization(CheckDecompositions):
                 self.check_two_qubit_weyl_specialization(
                     k1 @ Ud(a + da, b + db, c + dc) @ k2,
                     0.999,
-                    Specialization.IdEquiv,
+                    TwoQubitWeylIdEquiv,
                     {"rz": 4, "ry": 2},
                 )
 
@@ -847,7 +842,7 @@ class TestTwoQubitWeylDecompositionSpecialization(CheckDecompositions):
                 self.check_two_qubit_weyl_specialization(
                     k1 @ Ud(a + da, b + db, c + dc) @ k2,
                     0.999,
-                    Specialization.SWAPEquiv,
+                    TwoQubitWeylSWAPEquiv,
                     {"rz": 4, "ry": 2, "swap": 1},
                 )
 
@@ -861,7 +856,7 @@ class TestTwoQubitWeylDecompositionSpecialization(CheckDecompositions):
                 self.check_two_qubit_weyl_specialization(
                     k1 @ Ud(a + da, b + db, c + dc) @ k2,
                     0.999,
-                    Specialization.SWAPEquiv,
+                    TwoQubitWeylSWAPEquiv,
                     {"rz": 4, "ry": 2, "swap": 1},
                 )
 
@@ -875,7 +870,7 @@ class TestTwoQubitWeylDecompositionSpecialization(CheckDecompositions):
                 self.check_two_qubit_weyl_specialization(
                     k1 @ Ud(a + da, b + db, c + dc) @ k2,
                     0.999,
-                    Specialization.PartialSWAPEquiv,
+                    TwoQubitWeylPartialSWAPEquiv,
                     {"rz": 6, "ry": 3, "rxx": 1, "ryy": 1, "rzz": 1},
                 )
 
@@ -889,7 +884,7 @@ class TestTwoQubitWeylDecompositionSpecialization(CheckDecompositions):
                 self.check_two_qubit_weyl_specialization(
                     k1 @ Ud(a + da, b + db, c + dc) @ k2,
                     0.999,
-                    Specialization.PartialSWAPFlipEquiv,
+                    TwoQubitWeylPartialSWAPFlipEquiv,
                     {"rz": 6, "ry": 3, "rxx": 1, "ryy": 1, "rzz": 1},
                 )
 
@@ -903,7 +898,7 @@ class TestTwoQubitWeylDecompositionSpecialization(CheckDecompositions):
                 self.check_two_qubit_weyl_specialization(
                     k1 @ Ud(a + da, b + db, c + dc) @ k2,
                     0.999,
-                    Specialization.fSimaabEquiv,
+                    TwoQubitWeylfSimaabEquiv,
                     {"rz": 7, "ry": 4, "rxx": 1, "ryy": 1, "rzz": 1},
                 )
 
@@ -917,7 +912,7 @@ class TestTwoQubitWeylDecompositionSpecialization(CheckDecompositions):
                 self.check_two_qubit_weyl_specialization(
                     k1 @ Ud(a + da, b + db, c + dc) @ k2,
                     0.999,
-                    Specialization.fSimabbEquiv,
+                    TwoQubitWeylfSimabbEquiv,
                     {"rx": 7, "ry": 4, "rxx": 1, "ryy": 1, "rzz": 1},
                 )
 
@@ -931,7 +926,7 @@ class TestTwoQubitWeylDecompositionSpecialization(CheckDecompositions):
                 self.check_two_qubit_weyl_specialization(
                     k1 @ Ud(a + da, b + db, c + dc) @ k2,
                     0.999,
-                    Specialization.fSimabmbEquiv,
+                    TwoQubitWeylfSimabmbEquiv,
                     {"rx": 7, "ry": 4, "rxx": 1, "ryy": 1, "rzz": 1},
                 )
 
@@ -945,7 +940,7 @@ class TestTwoQubitWeylDecompositionSpecialization(CheckDecompositions):
                 self.check_two_qubit_weyl_specialization(
                     k1 @ Ud(a + da, b + db, c + dc) @ k2,
                     0.999,
-                    Specialization.ControlledEquiv,
+                    TwoQubitWeylControlledEquiv,
                     {"rx": 6, "ry": 4, "rxx": 1},
                 )
 
@@ -959,7 +954,7 @@ class TestTwoQubitWeylDecompositionSpecialization(CheckDecompositions):
                 self.check_two_qubit_weyl_specialization(
                     k1 @ Ud(a + da, b + db, c + dc) @ k2,
                     0.999,
-                    Specialization.MirrorControlledEquiv,
+                    TwoQubitWeylMirrorControlledEquiv,
                     {"rz": 6, "ry": 4, "rzz": 1, "swap": 1},
                 )
 
@@ -973,7 +968,7 @@ class TestTwoQubitWeylDecompositionSpecialization(CheckDecompositions):
                 self.check_two_qubit_weyl_specialization(
                     k1 @ Ud(a + da, b + db, c + dc) @ k2,
                     0.999,
-                    Specialization.General,
+                    TwoQubitWeylGeneral,
                     {"rz": 8, "ry": 4, "rxx": 1, "ryy": 1, "rzz": 1},
                 )
 
diff --git a/test/python/transpiler/test_1q.py b/test/python/transpiler/test_1q.py
index 31975456f..50bdc7b24 100644
--- a/test/python/transpiler/test_1q.py
+++ b/test/python/transpiler/test_1q.py
@@ -1,6 +1,6 @@
 # This code is part of Qiskit.
 #
-# (C) Copyright IBM 2019.
+# (C) Copyright IBM 2019, 2024.
 #
 # This code is licensed under the Apache License, Version 2.0. You may
 # obtain a copy of this license in the LICENSE.txt file in the root directory
@@ -17,6 +17,7 @@ from ddt import ddt
 from qiskit import QuantumCircuit
 from qiskit.compiler import transpile
 from qiskit.providers.fake_provider import Fake1Q
+from qiskit.providers.basic_provider import BasicSimulator
 from qiskit.transpiler import TranspilerError
 from test import combine  # pylint: disable=wrong-import-order
 from test import QiskitTestCase  # pylint: disable=wrong-import-order
@@ -76,9 +77,7 @@ class Test1QWorking(QiskitTestCase):
         name="{circuit.__name__}_level{level}_valid",
     )
     def test_simulator(self, circuit, level):
-        """All the levels with all the 1Q simulator backend"""
-        # Set fake backend config to simulator
-        backend = Fake1Q()
-        backend._configuration.simulator = True
+        """All the levels with a simulator backend"""
+        backend = BasicSimulator()
         result = transpile(circuit(), backend=backend, optimization_level=level, seed_transpiler=42)
         self.assertIsInstance(result, QuantumCircuit)
diff --git a/test/python/transpiler/test_preset_passmanagers.py b/test/python/transpiler/test_preset_passmanagers.py
index 0382c83ab..c0f2dde59 100644
--- a/test/python/transpiler/test_preset_passmanagers.py
+++ b/test/python/transpiler/test_preset_passmanagers.py
@@ -324,7 +324,7 @@ class TestPassesInspection(QiskitTestCase):
         qc = QuantumCircuit(qr)
         qc.cx(qr[2], qr[4])
 
-        backend = GenericBackendV2(num_qubits=14, coupling_map=MELBOURNE_CMAP)
+        backend = GenericBackendV2(num_qubits=14, coupling_map=MELBOURNE_CMAP, seed=42)
 
         _ = transpile(qc, backend, optimization_level=level, callback=self.callback)
 
@@ -413,7 +413,7 @@ class TestPassesInspection(QiskitTestCase):
                 """Custom post translation stage."""
                 return "custom_stage_for_test"
 
-        target = TargetBackend(num_qubits=7)
+        target = TargetBackend(num_qubits=7, seed=42)
         qr = QuantumRegister(2, "q")
         qc = QuantumCircuit(qr)
         qc.h(qr[0])
@@ -425,7 +425,7 @@ class TestPassesInspection(QiskitTestCase):
 
     def test_level1_runs_vf2post_layout_when_routing_required(self):
         """Test that if we run routing as part of sabre layout VF2PostLayout runs."""
-        target = GenericBackendV2(num_qubits=7, coupling_map=LAGOS_CMAP)
+        target = GenericBackendV2(num_qubits=7, coupling_map=LAGOS_CMAP, seed=42)
         qc = QuantumCircuit(5)
         qc.h(0)
         qc.cy(0, 1)
@@ -448,7 +448,7 @@ class TestPassesInspection(QiskitTestCase):
 
     def test_level1_runs_vf2post_layout_when_routing_method_set_and_required(self):
         """Test that if we run routing as part of sabre layout VF2PostLayout runs."""
-        target = GenericBackendV2(num_qubits=7, coupling_map=LAGOS_CMAP)
+        target = GenericBackendV2(num_qubits=7, coupling_map=LAGOS_CMAP, seed=42)
         qc = QuantumCircuit(5)
         qc.h(0)
         qc.cy(0, 1)
@@ -473,7 +473,10 @@ class TestPassesInspection(QiskitTestCase):
     def test_level1_not_runs_vf2post_layout_when_layout_method_set(self):
         """Test that if we don't run VF2PostLayout with custom layout_method."""
         target = GenericBackendV2(
-            num_qubits=7, basis_gates=["cx", "id", "rz", "sx", "x"], coupling_map=LAGOS_CMAP
+            num_qubits=7,
+            basis_gates=["cx", "id", "rz", "sx", "x"],
+            coupling_map=LAGOS_CMAP,
+            seed=42,
         )
         qc = QuantumCircuit(5)
         qc.h(0)
@@ -495,7 +498,10 @@ class TestPassesInspection(QiskitTestCase):
     def test_level1_not_run_vf2post_layout_when_trivial_is_perfect(self):
         """Test that if we find a trivial perfect layout we don't run vf2post."""
         target = GenericBackendV2(
-            num_qubits=7, basis_gates=["cx", "id", "rz", "sx", "x"], coupling_map=LAGOS_CMAP
+            num_qubits=7,
+            basis_gates=["cx", "id", "rz", "sx", "x"],
+            coupling_map=LAGOS_CMAP,
+            seed=42,
         )
         qc = QuantumCircuit(2)
         qc.h(0)
@@ -512,7 +518,10 @@ class TestPassesInspection(QiskitTestCase):
     def test_level1_not_run_vf2post_layout_when_vf2layout_is_perfect(self):
         """Test that if we find a vf2 perfect layout we don't run vf2post."""
         target = GenericBackendV2(
-            num_qubits=7, basis_gates=["cx", "id", "rz", "sx", "x"], coupling_map=LAGOS_CMAP
+            num_qubits=7,
+            basis_gates=["cx", "id", "rz", "sx", "x"],
+            coupling_map=LAGOS_CMAP,
+            seed=42,
         )
         qc = QuantumCircuit(4)
         qc.h(0)
@@ -531,7 +540,10 @@ class TestPassesInspection(QiskitTestCase):
     def test_level1_runs_vf2post_layout_when_routing_required_control_flow(self):
         """Test that if we run routing as part of sabre layout VF2PostLayout runs."""
         target = GenericBackendV2(
-            num_qubits=7, basis_gates=["cx", "id", "rz", "sx", "x"], coupling_map=LAGOS_CMAP
+            num_qubits=7,
+            basis_gates=["cx", "id", "rz", "sx", "x"],
+            coupling_map=LAGOS_CMAP,
+            seed=42,
         )
         _target = target.target
         target._target.add_instruction(ForLoopOp, name="for_loop")
@@ -558,7 +570,10 @@ class TestPassesInspection(QiskitTestCase):
     def test_level1_not_runs_vf2post_layout_when_layout_method_set_control_flow(self):
         """Test that if we don't run VF2PostLayout with custom layout_method."""
         target = GenericBackendV2(
-            num_qubits=7, basis_gates=["cx", "id", "rz", "sx", "x"], coupling_map=LAGOS_CMAP
+            num_qubits=7,
+            basis_gates=["cx", "id", "rz", "sx", "x"],
+            coupling_map=LAGOS_CMAP,
+            seed=42,
         )
         _target = target.target
         target._target.add_instruction(ForLoopOp, name="for_loop")
@@ -584,7 +599,10 @@ class TestPassesInspection(QiskitTestCase):
     def test_level1_not_run_vf2post_layout_when_trivial_is_perfect_control_flow(self):
         """Test that if we find a trivial perfect layout we don't run vf2post."""
         target = GenericBackendV2(
-            num_qubits=7, basis_gates=["cx", "id", "rz", "sx", "x"], coupling_map=LAGOS_CMAP
+            num_qubits=7,
+            basis_gates=["cx", "id", "rz", "sx", "x"],
+            coupling_map=LAGOS_CMAP,
+            seed=42,
         )
         _target = target.target
         target._target.add_instruction(ForLoopOp, name="for_loop")
@@ -604,7 +622,10 @@ class TestPassesInspection(QiskitTestCase):
     def test_level1_not_run_vf2post_layout_when_vf2layout_is_perfect_control_flow(self):
         """Test that if we find a vf2 perfect layout we don't run vf2post."""
         target = GenericBackendV2(
-            num_qubits=7, basis_gates=["cx", "id", "rz", "sx", "x"], coupling_map=LAGOS_CMAP
+            num_qubits=7,
+            basis_gates=["cx", "id", "rz", "sx", "x"],
+            coupling_map=LAGOS_CMAP,
+            seed=42,
         )
         _target = target.target
         target._target.add_instruction(ForLoopOp, name="for_loop")
@@ -630,7 +651,7 @@ class TestInitialLayouts(QiskitTestCase):
 
     @data(0, 1, 2, 3)
     def test_layout_1711(self, level):
-        """Test that a user-given initial layout is respected,
+        """Test that a user-given initial layout is respected
         in the qobj.
 
         See: https://github.com/Qiskit/qiskit-terra/issues/1711
@@ -661,9 +682,7 @@ class TestInitialLayouts(QiskitTestCase):
             14: ancilla[12],
             15: qr[2],
         }
-
-        backend = Fake20QV1()
-        backend.configuration().coupling_map = RUESCHLIKON_CMAP
+        backend = GenericBackendV2(num_qubits=16, coupling_map=RUESCHLIKON_CMAP, seed=42)
         qc_b = transpile(qc, backend, initial_layout=initial_layout, optimization_level=level)
         qobj = assemble(qc_b)
 
@@ -672,7 +691,7 @@ class TestInitialLayouts(QiskitTestCase):
         compiled_ops = qobj.experiments[0].instructions
         for operation in compiled_ops:
             if operation.name == "cx":
-                self.assertIn(operation.qubits, backend.configuration().coupling_map)
+                self.assertIn(tuple(operation.qubits), backend.coupling_map)
                 self.assertIn(operation.qubits, [[15, 0], [15, 2]])
 
     @data(0, 1, 2, 3)
@@ -711,10 +730,8 @@ class TestInitialLayouts(QiskitTestCase):
             12: ancilla[7],
             13: ancilla[8],
         }
-        backend = Fake20QV1()
-        backend.configuration().coupling_map = MELBOURNE_CMAP
+        backend = GenericBackendV2(num_qubits=14, coupling_map=MELBOURNE_CMAP, seed=42)
         qc_b = transpile(qc, backend, initial_layout=initial_layout, optimization_level=level)
-
         self.assertEqual(qc_b._layout.initial_layout._p2v, final_layout)
 
         output_qr = qc_b.qregs[0]
@@ -766,7 +783,6 @@ class TestInitialLayouts(QiskitTestCase):
         }
 
         backend = Fake20QV1()
-
         qc_b = transpile(qc, backend, initial_layout=initial_layout, optimization_level=level)
 
         self.assertEqual(qc_b._layout.initial_layout._p2v, final_layout)
@@ -825,21 +841,21 @@ class TestFinalLayouts(QiskitTestCase):
             2: Qubit(QuantumRegister(15, "ancilla"), 2),
             3: Qubit(QuantumRegister(15, "ancilla"), 3),
             4: Qubit(QuantumRegister(15, "ancilla"), 4),
-            5: Qubit(QuantumRegister(15, "ancilla"), 5),
-            6: Qubit(QuantumRegister(15, "ancilla"), 6),
-            7: Qubit(QuantumRegister(15, "ancilla"), 7),
-            8: Qubit(QuantumRegister(3, "qr1"), 1),
-            9: Qubit(QuantumRegister(15, "ancilla"), 8),
-            10: Qubit(QuantumRegister(15, "ancilla"), 9),
-            11: Qubit(QuantumRegister(15, "ancilla"), 10),
-            12: Qubit(QuantumRegister(3, "qr1"), 0),
-            13: Qubit(QuantumRegister(3, "qr1"), 2),
-            14: Qubit(QuantumRegister(2, "qr2"), 1),
-            15: Qubit(QuantumRegister(15, "ancilla"), 11),
-            16: Qubit(QuantumRegister(15, "ancilla"), 12),
-            17: Qubit(QuantumRegister(15, "ancilla"), 13),
-            18: Qubit(QuantumRegister(15, "ancilla"), 14),
-            19: Qubit(QuantumRegister(2, "qr2"), 0),
+            5: Qubit(QuantumRegister(3, "qr1"), 2),
+            6: Qubit(QuantumRegister(2, "qr2"), 0),
+            7: Qubit(QuantumRegister(2, "qr2"), 1),
+            8: Qubit(QuantumRegister(15, "ancilla"), 5),
+            9: Qubit(QuantumRegister(15, "ancilla"), 6),
+            10: Qubit(QuantumRegister(3, "qr1"), 1),
+            11: Qubit(QuantumRegister(3, "qr1"), 0),
+            12: Qubit(QuantumRegister(15, "ancilla"), 7),
+            13: Qubit(QuantumRegister(15, "ancilla"), 8),
+            14: Qubit(QuantumRegister(15, "ancilla"), 9),
+            15: Qubit(QuantumRegister(15, "ancilla"), 10),
+            16: Qubit(QuantumRegister(15, "ancilla"), 11),
+            17: Qubit(QuantumRegister(15, "ancilla"), 12),
+            18: Qubit(QuantumRegister(15, "ancilla"), 13),
+            19: Qubit(QuantumRegister(15, "ancilla"), 14),
         }
 
         # Trivial layout
@@ -856,8 +872,8 @@ class TestFinalLayouts(QiskitTestCase):
             expected_layout_level2,
             expected_layout_level3,
         ]
-        backend = Fake20QV1()
-        backend.configuration().coupling_map = TOKYO_CMAP
+
+        backend = GenericBackendV2(num_qubits=20, coupling_map=TOKYO_CMAP, seed=42)
         result = transpile(qc, backend, optimization_level=level, seed_transpiler=42)
         self.assertEqual(result._layout.initial_layout._p2v, expected_layouts[level])
 
@@ -899,78 +915,32 @@ class TestFinalLayouts(QiskitTestCase):
         }
 
         sabre_layout = {
-            0: ancilla[0],
-            1: ancilla[1],
-            2: ancilla[2],
-            3: ancilla[3],
-            4: ancilla[4],
-            5: qr[2],
-            6: qr[1],
-            7: ancilla[6],
-            8: ancilla[7],
-            9: ancilla[8],
-            10: qr[3],
-            11: qr[0],
-            12: ancilla[9],
-            13: ancilla[10],
-            14: ancilla[11],
-            15: ancilla[5],
-            16: qr[4],
-            17: ancilla[12],
-            18: ancilla[13],
-            19: ancilla[14],
-        }
-
-        sabre_layout_lvl_2 = {
-            0: ancilla[0],
-            1: ancilla[1],
-            2: ancilla[2],
-            3: ancilla[3],
-            4: ancilla[4],
-            5: qr[2],
-            6: qr[1],
-            7: ancilla[6],
-            8: ancilla[7],
-            9: ancilla[8],
-            10: qr[3],
-            11: qr[0],
-            12: ancilla[9],
-            13: ancilla[10],
-            14: ancilla[11],
-            15: ancilla[5],
-            16: qr[4],
-            17: ancilla[12],
-            18: ancilla[13],
-            19: ancilla[14],
-        }
-
-        sabre_layout_lvl_3 = {
-            0: ancilla[0],
-            1: ancilla[1],
-            2: ancilla[2],
-            3: ancilla[3],
-            4: ancilla[4],
-            5: qr[2],
-            6: qr[1],
-            7: ancilla[6],
-            8: ancilla[7],
-            9: ancilla[8],
-            10: qr[3],
-            11: qr[0],
-            12: ancilla[9],
-            13: ancilla[10],
-            14: ancilla[11],
-            15: ancilla[5],
-            16: qr[4],
-            17: ancilla[12],
-            18: ancilla[13],
-            19: ancilla[14],
+            0: Qubit(QuantumRegister(15, "ancilla"), 0),
+            1: Qubit(QuantumRegister(15, "ancilla"), 1),
+            2: Qubit(QuantumRegister(15, "ancilla"), 2),
+            3: Qubit(QuantumRegister(15, "ancilla"), 3),
+            4: Qubit(QuantumRegister(15, "ancilla"), 4),
+            5: Qubit(QuantumRegister(5, "qr"), 1),
+            6: Qubit(QuantumRegister(5, "qr"), 0),
+            7: Qubit(QuantumRegister(5, "qr"), 4),
+            8: Qubit(QuantumRegister(15, "ancilla"), 6),
+            9: Qubit(QuantumRegister(15, "ancilla"), 7),
+            10: Qubit(QuantumRegister(5, "qr"), 2),
+            11: Qubit(QuantumRegister(5, "qr"), 3),
+            12: Qubit(QuantumRegister(15, "ancilla"), 5),
+            13: Qubit(QuantumRegister(15, "ancilla"), 8),
+            14: Qubit(QuantumRegister(15, "ancilla"), 9),
+            15: Qubit(QuantumRegister(15, "ancilla"), 10),
+            16: Qubit(QuantumRegister(15, "ancilla"), 11),
+            17: Qubit(QuantumRegister(15, "ancilla"), 12),
+            18: Qubit(QuantumRegister(15, "ancilla"), 13),
+            19: Qubit(QuantumRegister(15, "ancilla"), 14),
         }
 
         expected_layout_level0 = trivial_layout
         expected_layout_level1 = sabre_layout
-        expected_layout_level2 = sabre_layout_lvl_2
-        expected_layout_level3 = sabre_layout_lvl_3
+        expected_layout_level2 = sabre_layout
+        expected_layout_level3 = sabre_layout
 
         expected_layouts = [
             expected_layout_level0,
@@ -978,9 +948,7 @@ class TestFinalLayouts(QiskitTestCase):
             expected_layout_level2,
             expected_layout_level3,
         ]
-        backend = Fake20QV1()
-        backend.configuration().coupling_map = TOKYO_CMAP
-
+        backend = GenericBackendV2(num_qubits=20, coupling_map=TOKYO_CMAP, seed=42)
         result = transpile(qc, backend, optimization_level=level, seed_transpiler=42)
         self.assertEqual(result._layout.initial_layout._p2v, expected_layouts[level])
 
@@ -991,12 +959,10 @@ class TestFinalLayouts(QiskitTestCase):
         See: https://github.com/Qiskit/qiskit-terra/issues/5694 for more
         details
         """
-        backend = Fake20QV1()
-        backend.configuration().coupling_map = TOKYO_CMAP
-        config = backend.configuration()
+        backend = GenericBackendV2(num_qubits=20, coupling_map=TOKYO_CMAP, seed=42)
 
-        rows = [x[0] for x in config.coupling_map]
-        cols = [x[1] for x in config.coupling_map]
+        rows = [x[0] for x in backend.coupling_map]
+        cols = [x[1] for x in backend.coupling_map]
 
         adjacency_matrix = np.zeros((20, 20))
         adjacency_matrix[rows, cols] = 1
@@ -1255,7 +1221,7 @@ class TestGeneratePresetPassManagers(QiskitTestCase):
     @data(0, 1, 2, 3)
     def test_with_no_backend(self, optimization_level):
         """Test a passmanager is constructed with no backend and optimization level."""
-        target = GenericBackendV2(num_qubits=7, coupling_map=LAGOS_CMAP)
+        target = GenericBackendV2(num_qubits=7, coupling_map=LAGOS_CMAP, seed=42)
         pm = generate_preset_pass_manager(
             optimization_level,
             coupling_map=target.coupling_map,
@@ -1270,7 +1236,7 @@ class TestGeneratePresetPassManagers(QiskitTestCase):
     @data(0, 1, 2, 3)
     def test_with_no_backend_only_target(self, optimization_level):
         """Test a passmanager is constructed with a manual target and optimization level."""
-        target = GenericBackendV2(num_qubits=7, coupling_map=LAGOS_CMAP)
+        target = GenericBackendV2(num_qubits=7, coupling_map=LAGOS_CMAP, seed=42)
         pm = generate_preset_pass_manager(optimization_level, target=target.target)
         self.assertIsInstance(pm, PassManager)
 
@@ -1299,7 +1265,7 @@ class TestGeneratePresetPassManagers(QiskitTestCase):
                 """Custom post translation stage."""
                 return "custom_stage_for_test"
 
-        target = TargetBackend(num_qubits=7, coupling_map=LAGOS_CMAP)
+        target = TargetBackend(num_qubits=7, coupling_map=LAGOS_CMAP, seed=42)
         pm = generate_preset_pass_manager(optimization_level, backend=target)
         self.assertIsInstance(pm, PassManager)
 
@@ -1331,7 +1297,7 @@ class TestGeneratePresetPassManagers(QiskitTestCase):
                 """Custom post translation stage."""
                 return "custom_stage_for_test"
 
-        target = TargetBackend(num_qubits=7, coupling_map=LAGOS_CMAP)
+        target = TargetBackend(num_qubits=7, coupling_map=LAGOS_CMAP, seed=42)
         pm = generate_preset_pass_manager(optimization_level, backend=target)
         self.assertIsInstance(pm, PassManager)
 
@@ -1363,7 +1329,7 @@ class TestGeneratePresetPassManagers(QiskitTestCase):
                 """Custom post translation stage."""
                 return "custom_stage_for_test"
 
-        target = TargetBackend(num_qubits=7, coupling_map=LAGOS_CMAP)
+        target = TargetBackend(num_qubits=7, coupling_map=LAGOS_CMAP, seed=42)
         pm = generate_preset_pass_manager(optimization_level, backend=target)
         self.assertIsInstance(pm, PassManager)
 
@@ -1395,7 +1361,7 @@ class TestGeneratePresetPassManagers(QiskitTestCase):
                 """Custom post translation stage."""
                 return "custom_stage_for_test"
 
-        target = TargetBackend(num_qubits=7, coupling_map=LAGOS_CMAP)
+        target = TargetBackend(num_qubits=7, coupling_map=LAGOS_CMAP, seed=42)
         pm = generate_preset_pass_manager(optimization_level, backend=target)
         self.assertIsInstance(pm, PassManager)
 
diff --git a/test/python/transpiler/test_pulse_gate_pass.py b/test/python/transpiler/test_pulse_gate_pass.py
index 8de8ceb66..a11d4c4a6 100644
--- a/test/python/transpiler/test_pulse_gate_pass.py
+++ b/test/python/transpiler/test_pulse_gate_pass.py
@@ -16,6 +16,7 @@ import ddt
 
 from qiskit import pulse, circuit, transpile
 from qiskit.providers.fake_provider import Fake27QPulseV1, GenericBackendV2
+from qiskit.providers.models import GateConfig
 from qiskit.quantum_info.random import random_unitary
 from test import QiskitTestCase  # pylint: disable=wrong-import-order
 
@@ -185,6 +186,12 @@ class TestPulseGate(QiskitTestCase):
         backend.defaults().instruction_schedule_map.add(
             "my_gate", (1,), self.my_gate_q1, arguments=["P0"]
         )
+        # Add gate to backend configuration
+        backend.configuration().basis_gates.append("my_gate")
+        dummy_config = GateConfig(
+            name="my_gate", parameters=[], qasm_def="", coupling_map=[(0,), (1,)]
+        )
+        backend.configuration().gates.append(dummy_config)
         # Remove timing constraints to avoid triggering
         # scheduling passes.
         backend.configuration().timing_constraints = {}
@@ -212,6 +219,10 @@ class TestPulseGate(QiskitTestCase):
         backend.defaults().instruction_schedule_map.add(
             "my_gate", (0,), self.my_gate_q0, arguments=["P0"]
         )
+        # Add gate to backend configuration
+        backend.configuration().basis_gates.append("my_gate")
+        dummy_config = GateConfig(name="my_gate", parameters=[], qasm_def="", coupling_map=[(0,)])
+        backend.configuration().gates.append(dummy_config)
         # Remove timing constraints to avoid triggering
         # scheduling passes.
         backend.configuration().timing_constraints = {}
@@ -237,6 +248,10 @@ class TestPulseGate(QiskitTestCase):
         backend.defaults().instruction_schedule_map.add(
             "my_gate", (0,), self.my_gate_q0, arguments=["P0"]
         )
+        # Add gate to backend configuration
+        backend.configuration().basis_gates.append("my_gate")
+        dummy_config = GateConfig(name="my_gate", parameters=[], qasm_def="", coupling_map=[(0,)])
+        backend.configuration().gates.append(dummy_config)
         # Remove timing constraints to avoid triggering
         # scheduling passes.
         backend.configuration().timing_constraints = {}
@@ -263,6 +278,10 @@ class TestPulseGate(QiskitTestCase):
         backend.defaults().instruction_schedule_map.add(
             "my_gate", (0,), self.my_gate_q0, arguments=["P0"]
         )
+        # Add gate to backend configuration
+        backend.configuration().basis_gates.append("my_gate")
+        dummy_config = GateConfig(name="my_gate", parameters=[], qasm_def="", coupling_map=[(0,)])
+        backend.configuration().gates.append(dummy_config)
         # Remove timing constraints to avoid triggering
         # scheduling passes.
         backend.configuration().timing_constraints = {}
diff --git a/test/visual/mpl/circuit/references/control_flow_fold_minus_one.png b/test/visual/mpl/circuit/references/control_flow_fold_minus_one.png
deleted file mode 100644
index 41dccaa03ec3996c8826b2edd18c34e5fc81efdb..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 11611
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

diff --git a/test/visual/mpl/circuit/test_circuit_matplotlib_drawer.py b/test/visual/mpl/circuit/test_circuit_matplotlib_drawer.py
index e99cb3f62..e785bdf79 100644
--- a/test/visual/mpl/circuit/test_circuit_matplotlib_drawer.py
+++ b/test/visual/mpl/circuit/test_circuit_matplotlib_drawer.py
@@ -2228,27 +2228,6 @@ class TestCircuitMatplotlibDrawer(QiskitTestCase):
         )
         self.assertGreaterEqual(ratio, self.threshold)
 
-    def test_control_flow_with_fold_minus_one(self):
-        """Test control flow works with fold=-1. Qiskit issue #12012"""
-        qreg = QuantumRegister(2, "qr")
-        creg = ClassicalRegister(2, "cr")
-        circuit = QuantumCircuit(qreg, creg)
-        with circuit.if_test((creg[1], 1)):
-            circuit.h(0)
-            circuit.cx(0, 1)
-
-        fname = "control_flow_fold_minus_one.png"
-        self.circuit_drawer(circuit, output="mpl", filename=fname, fold=-1)
-
-        ratio = VisualTestUtilities._save_diff(
-            self._image_path(fname),
-            self._reference_path(fname),
-            fname,
-            FAILURE_DIFF_DIR,
-            FAILURE_PREFIX,
-        )
-        self.assertGreaterEqual(ratio, self.threshold)
-
     def test_annotated_operation(self):
         """Test AnnotatedOperations and other non-Instructions."""
         circuit = QuantumCircuit(3)
