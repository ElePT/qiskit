---
prelude: |
  Qiskit 0.45.0 is the last feature release before 1.0. It prepares the ground for the API
  changes we are planning to make in our first major release, including many removals of
  previously deprecated functionality as well as a series of new deprecations.

  .. note::
    If your project depends on Qiskit, it may rely on functionality that will no longer
    be supported in Qiskit 1.0. For this reason, recommend that you proactively cap your
    supported version to be ``<1.0``.

  On top of the deprecations and removals, here are the main feature highlights of this release:

  * Starting in this release, all unparametrized gates in the standard Qiskit library are now **singletons**.
    By default, these gates share a single instance in memory, so once a gate of a specific type, let's say
    :class:`~.XGate`, is instantiated, any subsequent instances of :class:`~.XGate` will be a reference to
    the first one. This results in a reduced memory and construction overhead when using
    multiple gates of the same type in a circuit. To realize this feature, new base classes have been
    introduced: :class:`.SingletonInstruction` and :class:`~.SingletonGate`. See feature notes for more details.

  * We have added a new **generic pass manager interface**, that can be found in the new
    :mod:`qiskit.passmanager` module. This is a generalization of the pass manager that was used to build the
    Qiskit transpiler, and it provides a generic framework that enables users to create new pass managers
    that use different intermediate representations (IRs). The module contains a generic pass manager,
    flow controllers, and provides infrastructure to manage the execution of pass manager tasks.
    This new interface was used to rebuild the existing pass manager in the :mod:`qiskit.transpiler` module,
    cleaning up technical debt in the code, and improving the usability and performance of pass manager.
    See feature and upgrade notes for more details.

  * 0.45.0 allows users to better interact with the layout permutations caused by the transpiler. The data
    contained in the :class:`~.TranspileLayout` class is now more accessible through a series of new methods
    and attributes. The new :meth:`.SparsePauliOp.apply_layout` method is another new addition that allows
    users to apply a specific layout permutation to a :class:`~.SparsePauliOp` observable that was built
    for an input circuit to the transpiler. See feature notes for more details.

  * Finally, we have introduced annotated operations with the new :class:`~.AnnotatedOperation` class,
    which allows to formulate complex circuit instructions as a base instruction with a set of modifiers.
    For example, instead of a specific operation type that implements the controlled inverse of a
    :class:`~.RXGate`, we can now use an annotated :class:`~.RXGate` with inverse and control attributes.
    See feature notes for more details.
